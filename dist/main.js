/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/reset.css":
/*!********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/reset.css ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* http://meyerweb.com/eric/tools/css/reset/ 
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed, 
figure, figcaption, footer, header, hgroup, 
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure, 
footer, header, hgroup, menu, nav, section {
	display: block;
}
body {
	line-height: 1;
}
ol, ul {
	list-style: none;
}
blockquote, q {
	quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
	content: '';
	content: none;
}
table {
	border-collapse: collapse;
	border-spacing: 0;
}`, "",{"version":3,"sources":["webpack://./src/styles/reset.css"],"names":[],"mappings":"AAAA;;;CAGC;;AAED;;;;;;;;;;;;;CAaC,SAAS;CACT,UAAU;CACV,SAAS;CACT,eAAe;CACf,aAAa;CACb,wBAAwB;AACzB;AACA,gDAAgD;AAChD;;CAEC,cAAc;AACf;AACA;CACC,cAAc;AACf;AACA;CACC,gBAAgB;AACjB;AACA;CACC,YAAY;AACb;AACA;;CAEC,WAAW;CACX,aAAa;AACd;AACA;CACC,yBAAyB;CACzB,iBAAiB;AAClB","sourcesContent":["/* http://meyerweb.com/eric/tools/css/reset/ \r\n   v2.0 | 20110126\r\n   License: none (public domain)\r\n*/\r\n\r\nhtml, body, div, span, applet, object, iframe,\r\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\r\na, abbr, acronym, address, big, cite, code,\r\ndel, dfn, em, img, ins, kbd, q, s, samp,\r\nsmall, strike, strong, sub, sup, tt, var,\r\nb, u, i, center,\r\ndl, dt, dd, ol, ul, li,\r\nfieldset, form, label, legend,\r\ntable, caption, tbody, tfoot, thead, tr, th, td,\r\narticle, aside, canvas, details, embed, \r\nfigure, figcaption, footer, header, hgroup, \r\nmenu, nav, output, ruby, section, summary,\r\ntime, mark, audio, video {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tborder: 0;\r\n\tfont-size: 100%;\r\n\tfont: inherit;\r\n\tvertical-align: baseline;\r\n}\r\n/* HTML5 display-role reset for older browsers */\r\narticle, aside, details, figcaption, figure, \r\nfooter, header, hgroup, menu, nav, section {\r\n\tdisplay: block;\r\n}\r\nbody {\r\n\tline-height: 1;\r\n}\r\nol, ul {\r\n\tlist-style: none;\r\n}\r\nblockquote, q {\r\n\tquotes: none;\r\n}\r\nblockquote:before, blockquote:after,\r\nq:before, q:after {\r\n\tcontent: '';\r\n\tcontent: none;\r\n}\r\ntable {\r\n\tborder-collapse: collapse;\r\n\tborder-spacing: 0;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/style.css":
/*!********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/style.css ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ./../images/cat-black-moon-pattern-repeating.png */ "./src/images/cat-black-moon-pattern-repeating.png"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `:root {
    --COL_mainBG: black;
    --COL_gameBG: antiquewhite;
    --COL_defaultText: white;
    --COL_altDefaultText: antiquewhite;

    --TINT_dark: rgba(0, 0, 0, .75);
    --TINT_lowDark: rgba(0, 0, 0, .25);
    --TINT_light: rgba(0, 254, 246, 0.2);
    --TINT_green_light: rgba(0, 255, 0, 0.2);
    --TINT_green_dark: rgba(0, 255, 0, 0.8);
    --TINT_red_light: rgba(255, 0, 0, .2);
    --TINT_brown_light: rgba(139, 69, 19, .5);

    --SIZE_defaultGap: 1.5em;
    --SIZE_defaultPadding: 1.5em;
}

html {
    height: 100%;
    width: 100%;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
    background-size: 33%;
    color: var(--COL_defaultText);
}

body {
    width: 100%;
    height: 100%;
}

h1 {
    font-size: 4em;
}

h3 {
    font-size: 2em;
}

#gameWindow {
    position: relative;
    width: 100%;
    height: 100%;
    background-color: var(--TINT_dark);
}
.fullscreen {
    position: absolute;
    width: 100%;
    height: 100%;
}

.fl-col-center {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}

.fl-center {
    display: flex;
    justify-content: center;
    align-items: center;
}

.gap {
    gap: var(--SIZE_defaultGap);
}

.pad {
    padding: var(--SIZE_defaultPadding);
}

.scene-container {
    width: 100%;
    height: 100%;
}

.section-container {
    position: relative;
    background-color: var(--TINT_light);
}

.quarter-box {
    width: 25%;
    aspect-ratio: 1;
}

.board-tile {
    width: 100%;
    height: 100%;
    border: 1px solid;
    box-sizing: border-box;
}
.blinder{
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:100%;
    background-color:black;
    z-index:99999;
}
/*Piece Placement*/
.pPlacement-tile:hover {
    border: 3px solid var(--COL_altDefaultText);
}

.tile-has-unit{
    background-color: blueviolet;
    border:none;
}

.tile-highlight-low{
    background-color: lightGreen;
}

.tile-highlight-high{
    background-color: rgb(0,200,0);
}

.tile-highlight-invalid{
    background-color: rgb(0,100,0);
}
.tile-placed-unit{
    background-color: yellow;
}
.tile-removable-unit{
    opacity: .5;
}
/*              */
.red-border {
    border: 1px solid red;
}

.border {
    border: 1px solid;
}

.border-2px {
    border: 2px solid;
}

/* Animations */
.blink {
    animation: 2s infinite alternate blink;
}

@keyframes blink {
    from {
        opacity: 100%;
    }

    33% {
        opacity: 100%
    }

    to {
        opacity: 0%;
    }
}`, "",{"version":3,"sources":["webpack://./src/styles/style.css"],"names":[],"mappings":"AAAA;IACI,mBAAmB;IACnB,0BAA0B;IAC1B,wBAAwB;IACxB,kCAAkC;;IAElC,+BAA+B;IAC/B,kCAAkC;IAClC,oCAAoC;IACpC,wCAAwC;IACxC,uCAAuC;IACvC,qCAAqC;IACrC,yCAAyC;;IAEzC,wBAAwB;IACxB,4BAA4B;AAChC;;AAEA;IACI,YAAY;IACZ,WAAW;IACX,yDAAyE;IACzE,oBAAoB;IACpB,6BAA6B;AACjC;;AAEA;IACI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,kCAAkC;AACtC;AACA;IACI,kBAAkB;IAClB,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,aAAa;IACb,sBAAsB;IACtB,uBAAuB;IACvB,mBAAmB;AACvB;;AAEA;IACI,aAAa;IACb,uBAAuB;IACvB,mBAAmB;AACvB;;AAEA;IACI,2BAA2B;AAC/B;;AAEA;IACI,mCAAmC;AACvC;;AAEA;IACI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,kBAAkB;IAClB,mCAAmC;AACvC;;AAEA;IACI,UAAU;IACV,eAAe;AACnB;;AAEA;IACI,WAAW;IACX,YAAY;IACZ,iBAAiB;IACjB,sBAAsB;AAC1B;AACA;IACI,iBAAiB;IACjB,MAAM;IACN,KAAK;IACL,UAAU;IACV,WAAW;IACX,sBAAsB;IACtB,aAAa;AACjB;AACA,kBAAkB;AAClB;IACI,2CAA2C;AAC/C;;AAEA;IACI,4BAA4B;IAC5B,WAAW;AACf;;AAEA;IACI,4BAA4B;AAChC;;AAEA;IACI,8BAA8B;AAClC;;AAEA;IACI,8BAA8B;AAClC;AACA;IACI,wBAAwB;AAC5B;AACA;IACI,WAAW;AACf;AACA,iBAAiB;AACjB;IACI,qBAAqB;AACzB;;AAEA;IACI,iBAAiB;AACrB;;AAEA;IACI,iBAAiB;AACrB;;AAEA,eAAe;AACf;IACI,sCAAsC;AAC1C;;AAEA;IACI;QACI,aAAa;IACjB;;IAEA;QACI;IACJ;;IAEA;QACI,WAAW;IACf;AACJ","sourcesContent":[":root {\r\n    --COL_mainBG: black;\r\n    --COL_gameBG: antiquewhite;\r\n    --COL_defaultText: white;\r\n    --COL_altDefaultText: antiquewhite;\r\n\r\n    --TINT_dark: rgba(0, 0, 0, .75);\r\n    --TINT_lowDark: rgba(0, 0, 0, .25);\r\n    --TINT_light: rgba(0, 254, 246, 0.2);\r\n    --TINT_green_light: rgba(0, 255, 0, 0.2);\r\n    --TINT_green_dark: rgba(0, 255, 0, 0.8);\r\n    --TINT_red_light: rgba(255, 0, 0, .2);\r\n    --TINT_brown_light: rgba(139, 69, 19, .5);\r\n\r\n    --SIZE_defaultGap: 1.5em;\r\n    --SIZE_defaultPadding: 1.5em;\r\n}\r\n\r\nhtml {\r\n    height: 100%;\r\n    width: 100%;\r\n    background-image: url('./../images/cat-black-moon-pattern-repeating.png');\r\n    background-size: 33%;\r\n    color: var(--COL_defaultText);\r\n}\r\n\r\nbody {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nh1 {\r\n    font-size: 4em;\r\n}\r\n\r\nh3 {\r\n    font-size: 2em;\r\n}\r\n\r\n#gameWindow {\r\n    position: relative;\r\n    width: 100%;\r\n    height: 100%;\r\n    background-color: var(--TINT_dark);\r\n}\r\n.fullscreen {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\n.fl-col-center {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n\r\n.fl-center {\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n\r\n.gap {\r\n    gap: var(--SIZE_defaultGap);\r\n}\r\n\r\n.pad {\r\n    padding: var(--SIZE_defaultPadding);\r\n}\r\n\r\n.scene-container {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\n.section-container {\r\n    position: relative;\r\n    background-color: var(--TINT_light);\r\n}\r\n\r\n.quarter-box {\r\n    width: 25%;\r\n    aspect-ratio: 1;\r\n}\r\n\r\n.board-tile {\r\n    width: 100%;\r\n    height: 100%;\r\n    border: 1px solid;\r\n    box-sizing: border-box;\r\n}\r\n.blinder{\r\n    position:absolute;\r\n    left:0;\r\n    top:0;\r\n    width:100%;\r\n    height:100%;\r\n    background-color:black;\r\n    z-index:99999;\r\n}\r\n/*Piece Placement*/\r\n.pPlacement-tile:hover {\r\n    border: 3px solid var(--COL_altDefaultText);\r\n}\r\n\r\n.tile-has-unit{\r\n    background-color: blueviolet;\r\n    border:none;\r\n}\r\n\r\n.tile-highlight-low{\r\n    background-color: lightGreen;\r\n}\r\n\r\n.tile-highlight-high{\r\n    background-color: rgb(0,200,0);\r\n}\r\n\r\n.tile-highlight-invalid{\r\n    background-color: rgb(0,100,0);\r\n}\r\n.tile-placed-unit{\r\n    background-color: yellow;\r\n}\r\n.tile-removable-unit{\r\n    opacity: .5;\r\n}\r\n/*              */\r\n.red-border {\r\n    border: 1px solid red;\r\n}\r\n\r\n.border {\r\n    border: 1px solid;\r\n}\r\n\r\n.border-2px {\r\n    border: 2px solid;\r\n}\r\n\r\n/* Animations */\r\n.blink {\r\n    animation: 2s infinite alternate blink;\r\n}\r\n\r\n@keyframes blink {\r\n    from {\r\n        opacity: 100%;\r\n    }\r\n\r\n    33% {\r\n        opacity: 100%\r\n    }\r\n\r\n    to {\r\n        opacity: 0%;\r\n    }\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {



module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);

  // If url is already wrapped in quotes, remove them
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }

  // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./src/styles/reset.css":
/*!******************************!*\
  !*** ./src/styles/reset.css ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./reset.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles/reset.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/styles/style.css":
/*!******************************!*\
  !*** ./src/styles/style.css ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./style.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles/style.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./src/scripts/game-state.js":
/*!***********************************!*\
  !*** ./src/scripts/game-state.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   setDummyUnits: () => (/* binding */ setDummyUnits)
/* harmony export */ });
/* harmony import */ var _gameboard_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gameboard-manager */ "./src/scripts/gameboard-manager.js");
/* harmony import */ var _scene_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scene-manager */ "./src/scripts/scene-manager.js");



const BOARD_WIDTH = 10;
const BOARD_HEIGHT = 10;
const PIECE_COUNT = 5;
const PIECE_LENGTH_ARRAY = [0, 0, 1, 1, 1, 1, 1]; //index == piece length  value == piece count of said length
let _isSinglePlayer;

let _currentPlayer = 'p1';

//todo: change gamestate get/sets to individual objects with get/set and all references
const gameState = {
    get: {
        game: {
            isSinglePlayer: () => _isSinglePlayer,
            boardWidth: () => BOARD_WIDTH,
            boardHeight: () => BOARD_HEIGHT,
            pieceCount: () => PIECE_COUNT,
        },
        scene: {
            currentPlayer: () => _currentPlayer,
        },
    },
    set: {
        game: {
            isSinglePlayer: (bool) => {
                if (_isSinglePlayer !== undefined) {
                    console.log(`Can not change number of players. Returning.`);
                    return;
                }
                if ((bool !== true)
                    && bool !== false) {
                    console.log(`${bool} is not boolean. Returning.`);
                    return;
                }
                _isSinglePlayer = bool;
            }
        },
        scene: {
            swapPlayers: () => {
                if (_isSinglePlayer) return _currentPlayer;
                if (_currentPlayer === 'p1') _currentPlayer = 'p2';
                else _currentPlayer = 'p1';
                return _currentPlayer;
            },
            setCurrentPlayer: (playerRef) => {
                if (playerRef !== 'p1'
                    && playerRef !== 'p2') return console.log(`Invalid playerRef: ${playerRef}`);
                _currentPlayer = playerRef;
            }
        },
    },
    p1: _generatePlayerObj(),
    p2: _generatePlayerObj(),
    p0: { //here for intelisense
        get: {
            player: () => {},
            units: () => {},
            gameboard: () => {},
        },
        set: {
            player: () => {},
            gameboard: () => {},
        },
    },
};


_generatePlayerObj(1);
_generatePlayerObj(2);

function _generatePlayerObj() {

    let _player;
    const _gameboard = (0,_gameboard_manager__WEBPACK_IMPORTED_MODULE_0__.gameboardFactory)(BOARD_WIDTH, BOARD_HEIGHT);
    const _units = _createUnitArray();

    const playerObj = {
        get: {
            player: () => _player,
            units: () => _units,
            gameboard: () => _gameboard,
        },
        set: {
            player: (player) => {
                if (_player !== undefined) return console.log('player already set. Returning.');
                _player = player;
            },
            gameboard: (gameboard) => {
                if (_gameboard !== undefined) return console.log('gameboard already set. Returning.');
                _gameboard = gameboard;
            },
        },
    };
    return playerObj;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (gameState);

function _createUnitArray() {
    const unitArray = [];
    for (let unitLength = 0; unitLength < PIECE_LENGTH_ARRAY.length; unitLength++) {
        for (let unitCount = PIECE_LENGTH_ARRAY[unitLength]; unitCount > 0; unitCount--) {
            unitArray.push((0,_gameboard_manager__WEBPACK_IMPORTED_MODULE_0__.unitFactory)(unitLength));
        }
    }
    return unitArray;
}

function setDummyUnits(){
    console.log('setting dummy units');
    const gameboardArray = [
        gameState.p1.get.gameboard(),
        gameState.p2.get.gameboard()
    ];
    let offset = 0;
    const units = gameState.p1.get.units();
    gameboardArray.forEach(gb =>{
        for(let i = offset; i < units.length + offset; i++){
            gb.placeUnit(units[i - offset],[0,i]);
        }
        offset++;
    })
}


/***/ }),

/***/ "./src/scripts/gameboard-manager.js":
/*!******************************************!*\
  !*** ./src/scripts/gameboard-manager.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   gameboardFactory: () => (/* binding */ gameboardFactory),
/* harmony export */   get2DIndex: () => (/* binding */ get2DIndex),
/* harmony export */   unitFactory: () => (/* binding */ unitFactory)
/* harmony export */ });
function gameboardFactory(width = 10, height = 10) {
    let _unitsRemaining = 0;
    const boardSize = width * height;
    const _boardArray = [];
    for (let i = 0; i < boardSize; i++) _boardArray.push(false);
    const _hitArray = [];
    for (let i = 0; i < boardSize; i++) _hitArray.push(false);

    const gameboard = {
        get: {
            unitsRemaining: () => { return _unitsRemaining },
            boardArray: () => { return _boardArray },
            hitArray: () => { return _hitArray },
            width: () => { return width },
            height: () => { return height },
        },
        placeUnit: (unit, coord, rotated) => {
            if(coord.x && coord.y) coord = [coord.x, coord.y]; //allows coord obj instead of array
            for (let i = 0; i < unit.get.length(); i++) {
                let j = rotated ?
                    get2DIndex(width, coord[0], coord[1] + i) :
                    get2DIndex(width, coord[0] + i, coord[1]);
                if (j instanceof Error ||
                    _boardArray[j])
                    return false;
            }
            for (let i = 0; i < unit.get.length(); i++) {
                let j = rotated ?
                    get2DIndex(width, coord[0], coord[1] + i) :
                    get2DIndex(width, coord[0] + i, coord[1]);
                _boardArray[j] = unit;
            }

            _unitsRemaining++;
            return true;
        },
        removeUnit: (unit) => {
            _boardArray.forEach(value => { if (value === unit) value = false; })
        },
        checkCoordEmpty: (coord) => {
            const index = get2DIndex(width, coord);
            if (_boardArray[index]) return false;
            return true;
        },
        receiveAttack: (coord) => {
            const i = get2DIndex(width, coord);

            if (_hitArray[i]) return false;
            _hitArray[i] = true;

            const unit = _boardArray[i];
            if (!unit) return 'miss';
            unit.hit();
            if (unit.isSunk()) {
                _unitsRemaining--;
                return 'sunk';
            }
            return 'hit';
        },
        isGameOver: () => { return _unitsRemaining <= 0 },
    }
    return gameboard;
}

let _unitID = 1000;
function unitFactory(length) {
    const _id = _unitID++;
    const _length = length;
    let _hits = 0;

    const unit = {
        get: {
            id: () => { return _id },
            length: () => { return _length }
        },
        hit: () => { _hits++; },
        isSunk: () => { return (_hits >= _length) }
    }
    return unit;
}

function get2DIndex(rowLength, x, y) {
    let a, b;
    if(x.x && x.y){ //if using coordObj, convert to coordArray
        x = [x.x,x.y];
    }
    if (x[0] === undefined) {
        a = x;
        b = y;
    } else {
        a = x[0];
        b = x[1];
    }
    if (a >= rowLength)
        return new Error('Index out of bounds of rowLength.');
    if ((a < 0) ||
        (b < 0))
        return new Error('Index can not be negative.');
    return a * rowLength + b;
}



/***/ }),

/***/ "./src/scripts/player-factory.js":
/*!***************************************!*\
  !*** ./src/scripts/player-factory.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function playerFactory(name, type = 'human') {
    let _games = 0;
    let _wins = 0;
    let _streak = 0;

    const player = {
        get: {
            name: () => { return name; },
            type: () => { return type; },
            games: () => {return _games},
            wins: ()=>{return _wins},
            streak: ()=>{return _streak},
        },
        addGamePlayed:(wasWon)=>{
            _games++;
            if(wasWon){
                _wins++;
                _streak++;
            }
            else _streak = 0;
        }
    }

    return player;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (playerFactory);

/***/ }),

/***/ "./src/scripts/scene-manager.js":
/*!**************************************!*\
  !*** ./src/scripts/scene-manager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   generateGameTiles: () => (/* binding */ generateGameTiles),
/* harmony export */   initScene: () => (/* binding */ initScene)
/* harmony export */ });
/* harmony import */ var _scenes_blinder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scenes/blinder */ "./src/scripts/scenes/blinder.js");
/* harmony import */ var _scenes_title_screen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scenes/title-screen */ "./src/scripts/scenes/title-screen.js");
/* harmony import */ var _scenes_player_select__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scenes/player-select */ "./src/scripts/scenes/player-select.js");
/* harmony import */ var _scenes_piece_placement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scenes/piece-placement */ "./src/scripts/scenes/piece-placement.js");
/* harmony import */ var _scenes_main_game__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scenes/main-game */ "./src/scripts/scenes/main-game.js");
/* harmony import */ var _game_state__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./game-state */ "./src/scripts/game-state.js");






//import playerFactory from "./player-factory";
//import gameState from "./game-state";
//import gamePieces from "./game-pieces";

let scenes = {
    main: {},
    p1: {},
    p2: {},
};
const blinderScene = (0,_scenes_blinder__WEBPACK_IMPORTED_MODULE_0__["default"])();
let currentScene;
const gameWindow = document.getElementById('gameWindow');
const sceneManager = {
    initializeScenes: initializeScenes,
    getScenes: ()=>scenes,
    getCurrentScene: ()=>currentScene,
    loadScene,
    addBlinder,
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sceneManager);


function loadScene(sceneNode) {
    if (currentScene) currentScene.remove();
    if (!sceneNode) {
        console.log(`${{ sceneNode }} is not a valid node.`);
        return;
    }
    gameWindow.appendChild(sceneNode);
    if(sceneNode.sceneOnLoad) sceneNode.sceneOnLoad();
    currentScene = sceneNode;
}

function initializeScenes() {
    scenes.main.titleScreen = (0,_scenes_title_screen__WEBPACK_IMPORTED_MODULE_1__["default"])();
    scenes.main.playerSelect = (0,_scenes_player_select__WEBPACK_IMPORTED_MODULE_2__["default"])();
    [scenes.p1.piecePlacement, scenes.p2.piecePlacement] = (0,_scenes_piece_placement__WEBPACK_IMPORTED_MODULE_3__["default"])();
    scenes.main.game = (0,_scenes_main_game__WEBPACK_IMPORTED_MODULE_4__["default"])();
    //initMainGame();
    //initGameOver();
}
function addBlinder(){
    gameWindow.appendChild(blinderScene);
}

//exports



function initScene(templateID) {
    let template = document.getElementById(templateID);
    if (!template) {
        console.log(`${templateID} is an invalid template ID.`)
        return false;
    }
    return template.content.firstElementChild.cloneNode(true);
}
function generateGameTiles(parentNode) {
    const tileArr = [];
    const numTilesX = _game_state__WEBPACK_IMPORTED_MODULE_5__["default"].get.game.boardWidth();
    const numTilesY = _game_state__WEBPACK_IMPORTED_MODULE_5__["default"].get.game.boardHeight();
    _addGridBoardProperties(parentNode);
    for (let y = 0; y < numTilesY; y++) {
        for (let x = 0; x < numTilesX; x++) {
            const tile = document.createElement('div');
            tile.classList.add('board-tile');
            tile.setAttribute('posX',x);
            tile.setAttribute('posY',y);
            parentNode.appendChild(tile);
            tileArr.push(tile);
        }
    }
    return tileArr;
}

function _addGridBoardProperties(node){
    const width = _game_state__WEBPACK_IMPORTED_MODULE_5__["default"].get.game.boardWidth();
    const height = _game_state__WEBPACK_IMPORTED_MODULE_5__["default"].get.game.boardHeight();
    node.style.display = 'grid';
    node.style.gridTemplate = `repeat(${height}, 1fr) / repeat(${width}, 1fr)`
}

/***/ }),

/***/ "./src/scripts/scenes/blinder.js":
/*!***************************************!*\
  !*** ./src/scripts/scenes/blinder.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scene_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scene-manager */ "./src/scripts/scene-manager.js");

function initBlinder(){
    const scene = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_0__.initScene)('TEMPLATE_blinder');
    scene.addEventListener('click',()=>{
        scene.remove();
    })
    return scene;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initBlinder);

/***/ }),

/***/ "./src/scripts/scenes/main-game.js":
/*!*****************************************!*\
  !*** ./src/scripts/scenes/main-game.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _game_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../game-state */ "./src/scripts/game-state.js");
/* harmony import */ var _scene_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scene-manager */ "./src/scripts/scene-manager.js");



function initMainGameScene(){
    return createScene();
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initMainGameScene);

const moves = {
    p1:{
        recieveAttack:()=>{},
    },
    p2:{
        recieveAttack:()=>{},
    }
}

function createScene(){
    const scene = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_1__.initScene)('TEMPLATE_main-game');

    const defenseObj = new DefenseGameWindow();
    const offenseObj = new OffenseGameWindow();

    //draw tiles + tile behavior
    //place ships
    return scene;

    function DefenseGameWindow(){
        const parentNode = scene.querySelector("[gameID='gameBox-left']");
        const tiles = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_1__.generateGameTiles)(parentNode);

        this.receiveAttack = receiveAttack;

        function receiveAttack(coords){

        }
    }
    function OffenseGameWindow(){
        const parentNode = scene.querySelector("[gameID='gameBox-right']");

        function placeAttack(coords){
            
        }
    }
}

/***/ }),

/***/ "./src/scripts/scenes/piece-placement.js":
/*!***********************************************!*\
  !*** ./src/scripts/scenes/piece-placement.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scene_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scene-manager */ "./src/scripts/scene-manager.js");
/* harmony import */ var _game_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game-state */ "./src/scripts/game-state.js");




//export scene to sceneManager
function initPiecePlacement() {
    const scenes = {};
    scenes.p1 = createScene('p1');
    if (_game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.game.isSinglePlayer()) scenes.p2 = null;
    else scenes.p2 = createScene('p2');
    return [scenes.p1, scenes.p2];
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initPiecePlacement);

//internal workings start here
const PIECE_COUNT = _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.game.pieceCount();
const BOARD_WIDTH = _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.game.boardWidth();
const BOARD_HEIGHT = _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.game.boardHeight();

const CLASSES = {
    unit: 'tile-has-unit',
    lowHighlight: 'tile-highlight-low',
    highHighlight: 'tile-highlight-high',
    invalidHighlight: 'tile-highlight-invalid',
    removableUnit: 'tile-removable-unit',
};

const STATES = {
    current: 1,
    pickTile: 1,
    placeUnit: 2,
}

function createScene(playerRef) {
    //generate scene node from template
    const scene = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_0__.initScene)('TEMPLATE_piece-placement');
    //generate gameTiles and add properties
    const gameTiles = createGameTilesObj();
    //other scoped vars
    const playerObj = _game_state__WEBPACK_IMPORTED_MODULE_1__["default"][playerRef];
    const unitObj = createUnitObj(playerObj.get.units());
    const placedUnitsObj = new PlacedUnitsObj();

    return scene;
    //
    function createGameTilesObj() {
        const _submitElement = scene.querySelector('[pPlacementID="submit"]');
        const _gameBoxElement = scene.querySelector('[pPlacementID="gameBox"]');
        const _tileNodeArray = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_0__.generateGameTiles)(_gameBoxElement);
        const tileObjs = [];


        //removed }  here -in case that was the wrong one

        let selectedTile;
        //tile-class object arrays
        const activeHoverTiles = [];
        // const activeUnitTiles = [];

        for (let i = 0; i < _tileNodeArray.length; i++) {
            tileObjs.push(_tileFactory(_tileNodeArray[i], i));
        }
        return tileObjs;

        //private functions
        function _tileFactory(tileNode, index) {
            let currentUnit;
            const coords = {
                x: +tileNode.getAttribute('posX'),
                y: +tileNode.getAttribute('posY')
            }
            //tile object creation
            const tile = {
                getNode: () => tileNode,
                getCoordObj: () => coords,
                getCoordArray: () => [coords.x, coords.y],
                getIndex: () => index,
                unit: {
                    place: (unit) => {
                        if (currentUnit) return false;
                        currentUnit = unit;
                        placedUnitsObj.pushUnit(unit, tile);
                        tileNode.classList.add('tile-placed-unit');
                        unitObj.setUnitPlaced(unit);
                    },
                    removeFullUnit: (unit) => {
                        let tileArr = placedUnitsObj.getTileArrayFromPlacedUnit(unit);
                        tileArr.forEach(tile => {
                            tile.unit.removeSelfUnit();
                        });
                        placedUnitsObj.removeUnit(unit);
                    },
                    removeSelfUnit: () => {
                        currentUnit = undefined;
                        tileNode.classList.remove('tile-placed-unit');
                    },
                    getUnit: () => currentUnit,
                },
                nextTile: {
                    up: () => tileObjs[index - BOARD_WIDTH],
                    down: () => tileObjs[index + BOARD_WIDTH],
                    left: () => {
                        if (coords.x - 1 < 0) return false;
                        return tileObjs[index - 1];
                    },
                    right: () => {
                        if (coords.x + 1 >= BOARD_WIDTH) return false;
                        return tileObjs[index + 1];
                    },
                },
                highlight: {
                    selectable: () => { addHighlight(activeHoverTiles, CLASSES.lowHighlight); },
                    invalid: () => { addHighlight(activeHoverTiles, CLASSES.invalidHighlight); },
                    validPlaceUnit: () => { addHighlight(activeHoverTiles, CLASSES.highHighlight) },
                    removableUnit: () => { addHighlight(activeHoverTiles, CLASSES.removableUnit); },
                },
                selectedTile: {
                    unSelect: () => {
                        if (!selectedTile) return console.log('no selected tile');
                        selectedTile.getNode().classList.remove(CLASSES.highHighlight);
                        selectedTile = undefined;
                    },
                    selectThis: () => {
                        if (selectedTile) return false;
                        if (tile.unit.getUnit()) return false;
                        selectedTile = tile;
                        tileNode.classList.add(CLASSES.highHighlight);
                        return true;
                    },
                },
            }
            //event listeners
            tileNode.addEventListener('mouseover', (e) => {
                switch (STATES.current) {
                    case STATES.pickTile:
                        if (currentUnit) {
                            highlightUnit(currentUnit);
                        } else highlightAllplacements();
                        break;
                    case STATES.placeUnit:
                        highlightCurrentPlacement();
                        break;
                    default: console.log(`Invalid state: ${STATES.current}.`);
                }
            });

            tileNode.addEventListener('mouseleave', (e) => {
                removeHighlights(activeHoverTiles);
            });
            tileNode.addEventListener('click', (e) => {
                switch (STATES.current) {
                    case STATES.pickTile:
                        if (currentUnit) {
                            tile.unit.removeFullUnit(currentUnit);
                            highlightAllplacements();
                        }
                        else if (tile.selectedTile.selectThis())
                            STATES.current = STATES.placeUnit;
                        break;
                    case STATES.placeUnit:
                        if (tile.unit.getUnit()) return;
                        if (tile === selectedTile) { //clicking selectedTile removes it
                            tile.selectedTile.unSelect();
                            removeHighlights(activeHoverTiles);
                            STATES.current = STATES.pickTile;
                            highlightAllplacements();
                            break;
                        }
                        if (!placeUnit()) break;
                        tile.selectedTile.unSelect();
                        if(!tile.unit.getUnit())highlightAllplacements()
                        STATES.current = STATES.pickTile;

                        break;
                    default: console.log(`Invalid state: ${STATES.current}.`);
                }
            });

            _submitElement.addEventListener('click', submitScene);

            //highlights in all 4 directions for a distance of the current maxLength
            function highlightAllplacements() {
                if (unitObj.noUnitsAvailable()) return;
                tile.highlight.selectable();

                const directionTiles = [
                    new DirecionTileObj('up'),
                    new DirecionTileObj('down'),
                    new DirecionTileObj('left'),
                    new DirecionTileObj('right')
                ]
                const minLength = unitObj.getMinLength();
                const maxLength = unitObj.getMaxLength();

                for (let i = 2; i <= maxLength; i++)
                    directionTiles.forEach(obj => { obj.highlightNext(i); })

                function DirecionTileObj(direction) {
                    const tileArr = [tile];
                    let tileObj = tile;

                    this.highlightNext = (length) => {
                        if (!tileObj) return;
                        tileObj = tileObj.nextTile[direction]();

                        if (!tileObj || tileObj.unit.getUnit()) {
                            if (tileArr.length === 0) return tileObj = false;

                            for (length--; length >= minLength && !unitObj.getUnitOfLength(length); length--) {
                                tileObj = tileArr.pop();
                                tileObj.getNode().classList.remove(CLASSES.invalidHighlight);
                            }
                            return tileObj = false;
                        }
                        if (unitObj.getUnitOfLength(length))
                            tileObj.highlight.selectable();
                        else tileObj.highlight.invalid();
                        tileArr.push(tileObj);
                    }
                }
            }
            function highlightCurrentPlacement() {
                if (selectedTile === tile) {
                    tile.highlight.removableUnit();
                    highlightAllplacements();
                    return;
                }
                const tileArray = getTileArrayFrom(selectedTile, tile);
                let setInvalid = false;
                for (let i = 0; i < tileArray.length; i++) {
                    let tile = tileArray[i];
                    if (tile.unit.getUnit()) setInvalid = true;
                    if (setInvalid) return tile.highlight.invalid();
                    if (i >= 1 && !unitObj.getUnitOfLength(i + 1))
                        tile.highlight.invalid();
                    tile.highlight.validPlaceUnit();
                }
            }
            function highlightUnit(unit) {
                let tileArr = placedUnitsObj.getTileArrayFromPlacedUnit(unit);
                tileArr.forEach(tile => {
                    tile.highlight.removableUnit();
                })
            }
            function placeUnit() {
                const tileArray = getTileArrayFrom(selectedTile, tile);
                const unit = unitObj.getUnitOfLength(tileArray.length);
                if (!unit) return;                       //check if unit of length available
                for (let i = 0; i < tileArray.length; i++) {
                    let tile = tileArray[i];
                    if (tile.unit.getUnit()) return;          //check if any of the tiles have units
                    tile.unit.place(unit);
                }
                return true;
            }
            function getTileArrayFrom(tile1, tile2, limitByMaxLength = true) { //could be placed inside tile obj as getTileArrayTo
                if (tile1 === tile2) return [tile1];

                const startCoords = tile1.getCoordObj();
                const endCoords = tile2.getCoordObj();
                const xDif = endCoords.x - startCoords.x;
                const yDif = endCoords.y - startCoords.y;
                const inXAxis = Math.abs(yDif) <= Math.abs(xDif);

                let length;
                if (inXAxis) length = Math.abs(xDif);
                else length = Math.abs(yDif);
                if (limitByMaxLength && length >= unitObj.getMaxLength())
                    length = unitObj.getMaxLength() - 1; //-1 because starting at 0

                const tileArray = [tile1];
                let tempTile = tile1;

                for (let i = 0; i < length; i++) {
                    let direction;
                    if (!inXAxis && yDif <= 0) direction = 'up';
                    else if (!inXAxis) direction = 'down';
                    else if (xDif <= 0) direction = 'left'
                    else direction = 'right';
                    tempTile = tempTile.nextTile[direction]();
                    if (tempTile) tileArray.push(tempTile);
                }
                return tileArray;
            }

            function removeHighlights(tileClassObjArray) {
                while (tileClassObjArray.length > 0) {
                    let obj = tileClassObjArray.pop();
                    obj.tileNode.classList.remove(obj.className);
                }
            }
            function addHighlight(tileClassObjArray, className) {
                tileNode.classList.add(className);
                tileClassObjArray.push(new TileClassObj(tileNode, className))
            }
            return tile;
        }

    }
    function submitScene() {
        if (!unitObj.noUnitsAvailable()) return;
        const gameboard = playerObj.get.gameboard();
        const unitArray = unitObj.getPlacedUnits();
        unitArray.forEach(unit => {
            const gameUnit = unitObj.getRealUnitFromClone(unit);
            const tileArray = placedUnitsObj.getTileArrayFromPlacedUnit(unit);
            if (unit.get.length() === 1) { //shouldn't ever have a piece of length 1, but just in case
                gameboard.placeUnit(gameUnit, tileArray[0].getCoordArray());
                console.log(`There shouldn't be any units of length 1.`);
            }
            const startCoords = tileArray[0].getCoordObj();
            const endCoords = tileArray[tileArray.length - 1].getCoordObj();
            const inXaxis = startCoords.x === endCoords.x ? false : true;
            if (!gameboard.placeUnit(gameUnit, [startCoords.x, startCoords.y], !inXaxis)) {
                console.log('Error: trying to place unit on occupied tile.');
            }
        })
        const scenes = _scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getScenes();
        if (_game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.game.isSinglePlayer() || playerRef === 'p2') _scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].loadScene(scenes.main.game)
        else {
            _scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].addBlinder();
            _scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].loadScene(scenes.p2.piecePlacement)
        }
    }

    function TileClassObj(tileNode, className) {
        this.tileNode = tileNode;
        this.className = className;
    }

    function PlacedUnitsObj() {
        const placedUnitArr = [];

        this.pushUnit = (unit, tile) => {
            let placedUnit = placedUnitArr.find((placedUnit) => placedUnit.unit === unit);
            if (!placedUnit) {
                placedUnit = { unit, tileArr: [] };
                placedUnitArr.push(placedUnit);
            }
            let tileArr = placedUnit.tileArr;
            if (!tileArr.includes(tile)) tileArr.push(tile);
        }
        this.removeUnit = (unit) => {
            const index = placedUnitArr.findIndex((placedUnit) => placedUnit.unit === unit);
            if (index < 0) return false;
            unitObj.setUnitAvailable(unit);
            return placedUnitArr.splice(index, 1)[0];
        }
        this.getTileArrayFromPlacedUnit = (unit) => {
            const placedUnit = placedUnitArr.find((placedUnit) => placedUnit.unit === unit);
            if (!placedUnit) return [];
            sortTiles(placedUnit.tileArr)
            return placedUnit.tileArr;
        }
        function sortTiles(tileArr) {
            if (tileArr.length < 2) return;
            let axis = tileArr[0].getCoordObj().x === tileArr[1].getCoordObj().x ? 'y' : 'x';
            tileArr.sort((a, b) => a.getCoordObj()[axis] > b.getCoordObj()[axis])
        }
    }
}

function createUnitObj(unitArray) {
    const _availableUnits = [];
    const _placedUnits = [];
    let _maxLength = 0;
    let _minLength;
    //create semi-cloned units and fill unit array
    //  and set _maxLength
    unitArray.forEach((unit) => {
        _availableUnits.push(new CloneUnit(unit));
    })
    function CloneUnit(unit) {
        const id = unit.get.id();
        const length = unit.get.length();
        this.get = {
            id: () => id,
            length: () => length,
        };
    }
    function getUnitOfLength(length) {
        for (let i = 0; i < _availableUnits.length; i++) {
            if (_availableUnits[i].get.length() === length) return _availableUnits[i];
        }
        return false;
    }
    function setUnitPlaced(unit) {
        fromArrayToArray(_availableUnits, _placedUnits, unit);
        setLengthBounds();
    }
    function setUnitAvailable(unit) {
        fromArrayToArray(_placedUnits, _availableUnits, unit);
        setLengthBounds();
    }
    function setLengthBounds() {
        if (!_availableUnits.length) {
            _minLength = 0;
            _maxLength = 0;
            return;
        }
        _minLength = false;
        _maxLength = 0;
        for (let i = 0; i < _availableUnits.length; i++) {
            length = _availableUnits[i].get.length();
            if (_maxLength < length) _maxLength = length;
            if (!_minLength || _minLength > length) _minLength = length;
        }
    }
    function fromArrayToArray(fromArr, toArr, item) {
        const index = fromArr.indexOf(item);
        if (index < 0) return false;
        toArr.push(item);
        fromArr.splice(index, 1);
    }
    function getRealUnitFromClone(cloneUnit) {
        let id = cloneUnit.get.id();
        for (let i = 0; i < unitArray.length; i++) {
            if (id === unitArray[i].get.id())
                return unitArray[i];
        }
        return false;
    }
    const unitObj = {
        getAvailableUnitCount: () => _availableUnits.length,
        noUnitsAvailable: () => _availableUnits.length === 0,
        getPlacedUnits: () => _placedUnits,
        getMinLength: () => _minLength,
        getMaxLength: () => _maxLength,
        getUnitOfLength,
        setUnitPlaced,
        setUnitAvailable,
        getRealUnitFromClone,
    }
    setLengthBounds();
    return unitObj;
}

/***/ }),

/***/ "./src/scripts/scenes/player-select.js":
/*!*********************************************!*\
  !*** ./src/scripts/scenes/player-select.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scene_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scene-manager */ "./src/scripts/scene-manager.js");
/* harmony import */ var _player_factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../player-factory */ "./src/scripts/player-factory.js");
/* harmony import */ var _game_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../game-state */ "./src/scripts/game-state.js");





function initPlayerSelect() {
    let scene = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_0__.initScene)('TEMPLATE_player-select');
    const submitButton = scene.querySelector('[pSelectID="submit"]');
    const singlePlayerInput = scene.querySelector('[pSelectID="singlePlayer"]');
    const p1Input = scene.querySelector('[pSelectID="player1"]');
    const p2Input = scene.querySelector('[pSelectID="player2"]');


    submitButton.addEventListener('click', _onSubmit);
    function _onSubmit() {
        let singlePlayer = singlePlayerInput.checked;
        //p1
        let name = p1Input.value;
        if (name === '') name = 'Player1';
        let type = 'human';
        let player = (0,_player_factory__WEBPACK_IMPORTED_MODULE_1__["default"])(name, type);
        _game_state__WEBPACK_IMPORTED_MODULE_2__["default"].set.player1.player(player);

        //p2
        if (singlePlayer) {
            name = 'CPU';
            type = 'computer';
        }
        else {
            name = p2Input.value;
            if (name === '') name = 'Player 2';
        }
        player = (0,_player_factory__WEBPACK_IMPORTED_MODULE_1__["default"])(name, type);
        _game_state__WEBPACK_IMPORTED_MODULE_2__["default"].set.player2.player(player);
        //
        _game_state__WEBPACK_IMPORTED_MODULE_2__["default"].set.game.isSinglePlayer(singlePlayer);
        _scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].loadScene(_scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getScenes().p1.piecePlacement);
    }
    return scene;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initPlayerSelect);

/***/ }),

/***/ "./src/scripts/scenes/title-screen.js":
/*!********************************************!*\
  !*** ./src/scripts/scenes/title-screen.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scene_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scene-manager */ "./src/scripts/scene-manager.js");



function initTitleScreen() {
    let scene = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_0__.initScene)('TEMPLATE_title-screen');
    document.body.addEventListener('click', _onButtonPress);
    document.body.addEventListener('keypress', _onButtonPress);

    function _onButtonPress() {
        document.body.removeEventListener('click', _onButtonPress);
        document.body.removeEventListener('keypress', _onButtonPress);
        if (_scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getCurrentScene() == scene) _scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].loadScene(_scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getScenes().main.playerSelect);
        else console.log(`Current scene is not titleScreen. Removing titleScreen event listeners and returning.`);
    }
    return scene;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initTitleScreen);

/***/ }),

/***/ "./src/images/cat-black-moon-pattern-repeating.png":
/*!*********************************************************!*\
  !*** ./src/images/cat-black-moon-pattern-repeating.png ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "9b730c4d9de3300fd62e.png";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_reset_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/reset.css */ "./src/styles/reset.css");
/* harmony import */ var _styles_style_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles/style.css */ "./src/styles/style.css");
/* harmony import */ var _scripts_scene_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/scene-manager */ "./src/scripts/scene-manager.js");
/* harmony import */ var _scripts_game_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scripts/game-state */ "./src/scripts/game-state.js");






_scripts_scene_manager__WEBPACK_IMPORTED_MODULE_2__["default"].initializeScenes();
const scenes = _scripts_scene_manager__WEBPACK_IMPORTED_MODULE_2__["default"].getScenes();

//sceneManager.loadScene(scenes.main.titleScreen);

_scripts_scene_manager__WEBPACK_IMPORTED_MODULE_2__["default"].loadScene(scenes.p1.piecePlacement)
// setDummyUnits();
// sceneManager.loadScene(scenes.main.game);

})();

/******/ })()
;
//# sourceMappingURL=main.js.map