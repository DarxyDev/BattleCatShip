/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/reset.css":
/*!********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/reset.css ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `/* http://meyerweb.com/eric/tools/css/reset/ 
   v2.0 | 20110126
   License: none (public domain)
*/

html, body, div, span, applet, object, iframe,
h1, h2, h3, h4, h5, h6, p, blockquote, pre,
a, abbr, acronym, address, big, cite, code,
del, dfn, em, img, ins, kbd, q, s, samp,
small, strike, strong, sub, sup, tt, var,
b, u, i, center,
dl, dt, dd, ol, ul, li,
fieldset, form, label, legend,
table, caption, tbody, tfoot, thead, tr, th, td,
article, aside, canvas, details, embed, 
figure, figcaption, footer, header, hgroup, 
menu, nav, output, ruby, section, summary,
time, mark, audio, video {
	margin: 0;
	padding: 0;
	border: 0;
	font-size: 100%;
	font: inherit;
	vertical-align: baseline;
}
/* HTML5 display-role reset for older browsers */
article, aside, details, figcaption, figure, 
footer, header, hgroup, menu, nav, section {
	display: block;
}
body {
	line-height: 1;
}
ol, ul {
	list-style: none;
}
blockquote, q {
	quotes: none;
}
blockquote:before, blockquote:after,
q:before, q:after {
	content: '';
	content: none;
}
table {
	border-collapse: collapse;
	border-spacing: 0;
}`, "",{"version":3,"sources":["webpack://./src/styles/reset.css"],"names":[],"mappings":"AAAA;;;CAGC;;AAED;;;;;;;;;;;;;CAaC,SAAS;CACT,UAAU;CACV,SAAS;CACT,eAAe;CACf,aAAa;CACb,wBAAwB;AACzB;AACA,gDAAgD;AAChD;;CAEC,cAAc;AACf;AACA;CACC,cAAc;AACf;AACA;CACC,gBAAgB;AACjB;AACA;CACC,YAAY;AACb;AACA;;CAEC,WAAW;CACX,aAAa;AACd;AACA;CACC,yBAAyB;CACzB,iBAAiB;AAClB","sourcesContent":["/* http://meyerweb.com/eric/tools/css/reset/ \r\n   v2.0 | 20110126\r\n   License: none (public domain)\r\n*/\r\n\r\nhtml, body, div, span, applet, object, iframe,\r\nh1, h2, h3, h4, h5, h6, p, blockquote, pre,\r\na, abbr, acronym, address, big, cite, code,\r\ndel, dfn, em, img, ins, kbd, q, s, samp,\r\nsmall, strike, strong, sub, sup, tt, var,\r\nb, u, i, center,\r\ndl, dt, dd, ol, ul, li,\r\nfieldset, form, label, legend,\r\ntable, caption, tbody, tfoot, thead, tr, th, td,\r\narticle, aside, canvas, details, embed, \r\nfigure, figcaption, footer, header, hgroup, \r\nmenu, nav, output, ruby, section, summary,\r\ntime, mark, audio, video {\r\n\tmargin: 0;\r\n\tpadding: 0;\r\n\tborder: 0;\r\n\tfont-size: 100%;\r\n\tfont: inherit;\r\n\tvertical-align: baseline;\r\n}\r\n/* HTML5 display-role reset for older browsers */\r\narticle, aside, details, figcaption, figure, \r\nfooter, header, hgroup, menu, nav, section {\r\n\tdisplay: block;\r\n}\r\nbody {\r\n\tline-height: 1;\r\n}\r\nol, ul {\r\n\tlist-style: none;\r\n}\r\nblockquote, q {\r\n\tquotes: none;\r\n}\r\nblockquote:before, blockquote:after,\r\nq:before, q:after {\r\n\tcontent: '';\r\n\tcontent: none;\r\n}\r\ntable {\r\n\tborder-collapse: collapse;\r\n\tborder-spacing: 0;\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/styles/style.css":
/*!********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/styles/style.css ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ "./node_modules/css-loader/dist/runtime/getUrl.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2__);
// Imports



var ___CSS_LOADER_URL_IMPORT_0___ = new URL(/* asset import */ __webpack_require__(/*! ./../images/cat-black-moon-pattern-repeating.png */ "./src/images/cat-black-moon-pattern-repeating.png"), __webpack_require__.b);
var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
var ___CSS_LOADER_URL_REPLACEMENT_0___ = _node_modules_css_loader_dist_runtime_getUrl_js__WEBPACK_IMPORTED_MODULE_2___default()(___CSS_LOADER_URL_IMPORT_0___);
// Module
___CSS_LOADER_EXPORT___.push([module.id, `:root {
    --COL_mainBG: black;
    --COL_gameBG: antiquewhite;
    --COL_defaultText: white;
    --COL_altDefaultText: antiquewhite;

    --TINT_dark: rgba(0, 0, 0, .75);
    --TINT_lowDark: rgba(0, 0, 0, .25);
    --TINT_light: rgba(0, 254, 246, 0.2);
    --TINT_green_light: rgba(0, 255, 0, 0.2);
    --TINT_green_dark: rgba(0, 255, 0, 0.8);
    --TINT_red_light: rgba(255, 0, 0, .2);
    --TINT_brown_light: rgba(139, 69, 19, .5);

    --SIZE_defaultGap: 1.5em;
    --SIZE_defaultPadding: 1.5em;
}

html {
    height: 100%;
    width: 100%;
    background-image: url(${___CSS_LOADER_URL_REPLACEMENT_0___});
    background-size: 33%;
    color: var(--COL_defaultText);
}

body {
    width: 100%;
    height: 100%;
}

h1 {
    font-size: 4em;
}

h3 {
    font-size: 2em;
}

#gameWindow {
    position: relative;
    width: 100%;
    height: 100%;
    background-color: var(--TINT_dark);
}
.fullscreen {
    position: absolute;
    width: 100%;
    height: 100%;
}

.fl-col-center {
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
}
.full-size{
    width:100%;
    height:100%;
}
.w100{
    width:100%;
}
.fl-center {
    display: flex;
    justify-content: center;
    align-items: center;
}

.gap {
    gap: var(--SIZE_defaultGap);
}

.pad {
    padding: var(--SIZE_defaultPadding);
}
.hover-shade:hover{
    opacity:.5;
}

.scene-container {
    width: 100%;
    height: 100%;
}

.section-container {
    position: relative;
    background-color: var(--TINT_light);
}

.quarter-box {
    width: 25%;
    aspect-ratio: 1;
}

.board-tile {
    width: 100%;
    height: 100%;
    border: 1px solid;
    box-sizing: border-box;
}
.blinder{
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:100%;
    background-color:black;
    z-index:99999;
}
/*Piece Placement*/
.pPlacement-tile:hover {
    border: 3px solid var(--COL_altDefaultText);
}

.tile-has-unit{
    background-color: blueviolet;
    border:none;
}

.tile-highlight-low{
    background-color: lightGreen;
}

.tile-highlight-high{
    background-color: rgb(0,200,0);
}

.tile-highlight-invalid{
    background-color: rgb(0,100,0);
}
.tile-placed-unit{
    background-color: yellow;
}
.tile-removable-unit{
    opacity: .5;
}
/* main game */
.unit-miss{
    background-color: var(--TINT_dark);
}
.unit-hit{
    background-color: var(--TINT_green_light);
}
.unit-sunk{
    background-color: var(--TINT_red_light);
}
.tile-miss{
    background-color: var(--TINT_dark);
}
.tile-hit{
    background-color: var(--TINT_green_light);
}
.tile-sunk{
    background-color: var(--TINT_red_light);
}
.red-border {
    border: 1px solid red;
}

.border {
    border: 1px solid;
}

.border-2px {
    border: 2px solid;
}
.text-box{
    font-size:2rem;
    line-height: 3rem;
    background-color: var(--TINT_dark);
    text-align: center;
}
/* Animations */
.blink {
    animation: 2s infinite alternate blink;
}

@keyframes blink {
    from {
        opacity: 100%;
    }

    33% {
        opacity: 100%
    }

    to {
        opacity: 0%;
    }
}`, "",{"version":3,"sources":["webpack://./src/styles/style.css"],"names":[],"mappings":"AAAA;IACI,mBAAmB;IACnB,0BAA0B;IAC1B,wBAAwB;IACxB,kCAAkC;;IAElC,+BAA+B;IAC/B,kCAAkC;IAClC,oCAAoC;IACpC,wCAAwC;IACxC,uCAAuC;IACvC,qCAAqC;IACrC,yCAAyC;;IAEzC,wBAAwB;IACxB,4BAA4B;AAChC;;AAEA;IACI,YAAY;IACZ,WAAW;IACX,yDAAyE;IACzE,oBAAoB;IACpB,6BAA6B;AACjC;;AAEA;IACI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,cAAc;AAClB;;AAEA;IACI,kBAAkB;IAClB,WAAW;IACX,YAAY;IACZ,kCAAkC;AACtC;AACA;IACI,kBAAkB;IAClB,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,aAAa;IACb,sBAAsB;IACtB,uBAAuB;IACvB,mBAAmB;AACvB;AACA;IACI,UAAU;IACV,WAAW;AACf;AACA;IACI,UAAU;AACd;AACA;IACI,aAAa;IACb,uBAAuB;IACvB,mBAAmB;AACvB;;AAEA;IACI,2BAA2B;AAC/B;;AAEA;IACI,mCAAmC;AACvC;AACA;IACI,UAAU;AACd;;AAEA;IACI,WAAW;IACX,YAAY;AAChB;;AAEA;IACI,kBAAkB;IAClB,mCAAmC;AACvC;;AAEA;IACI,UAAU;IACV,eAAe;AACnB;;AAEA;IACI,WAAW;IACX,YAAY;IACZ,iBAAiB;IACjB,sBAAsB;AAC1B;AACA;IACI,iBAAiB;IACjB,MAAM;IACN,KAAK;IACL,UAAU;IACV,WAAW;IACX,sBAAsB;IACtB,aAAa;AACjB;AACA,kBAAkB;AAClB;IACI,2CAA2C;AAC/C;;AAEA;IACI,4BAA4B;IAC5B,WAAW;AACf;;AAEA;IACI,4BAA4B;AAChC;;AAEA;IACI,8BAA8B;AAClC;;AAEA;IACI,8BAA8B;AAClC;AACA;IACI,wBAAwB;AAC5B;AACA;IACI,WAAW;AACf;AACA,cAAc;AACd;IACI,kCAAkC;AACtC;AACA;IACI,yCAAyC;AAC7C;AACA;IACI,uCAAuC;AAC3C;AACA;IACI,kCAAkC;AACtC;AACA;IACI,yCAAyC;AAC7C;AACA;IACI,uCAAuC;AAC3C;AACA;IACI,qBAAqB;AACzB;;AAEA;IACI,iBAAiB;AACrB;;AAEA;IACI,iBAAiB;AACrB;AACA;IACI,cAAc;IACd,iBAAiB;IACjB,kCAAkC;IAClC,kBAAkB;AACtB;AACA,eAAe;AACf;IACI,sCAAsC;AAC1C;;AAEA;IACI;QACI,aAAa;IACjB;;IAEA;QACI;IACJ;;IAEA;QACI,WAAW;IACf;AACJ","sourcesContent":[":root {\r\n    --COL_mainBG: black;\r\n    --COL_gameBG: antiquewhite;\r\n    --COL_defaultText: white;\r\n    --COL_altDefaultText: antiquewhite;\r\n\r\n    --TINT_dark: rgba(0, 0, 0, .75);\r\n    --TINT_lowDark: rgba(0, 0, 0, .25);\r\n    --TINT_light: rgba(0, 254, 246, 0.2);\r\n    --TINT_green_light: rgba(0, 255, 0, 0.2);\r\n    --TINT_green_dark: rgba(0, 255, 0, 0.8);\r\n    --TINT_red_light: rgba(255, 0, 0, .2);\r\n    --TINT_brown_light: rgba(139, 69, 19, .5);\r\n\r\n    --SIZE_defaultGap: 1.5em;\r\n    --SIZE_defaultPadding: 1.5em;\r\n}\r\n\r\nhtml {\r\n    height: 100%;\r\n    width: 100%;\r\n    background-image: url('./../images/cat-black-moon-pattern-repeating.png');\r\n    background-size: 33%;\r\n    color: var(--COL_defaultText);\r\n}\r\n\r\nbody {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\nh1 {\r\n    font-size: 4em;\r\n}\r\n\r\nh3 {\r\n    font-size: 2em;\r\n}\r\n\r\n#gameWindow {\r\n    position: relative;\r\n    width: 100%;\r\n    height: 100%;\r\n    background-color: var(--TINT_dark);\r\n}\r\n.fullscreen {\r\n    position: absolute;\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\n.fl-col-center {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n.full-size{\r\n    width:100%;\r\n    height:100%;\r\n}\r\n.w100{\r\n    width:100%;\r\n}\r\n.fl-center {\r\n    display: flex;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n\r\n.gap {\r\n    gap: var(--SIZE_defaultGap);\r\n}\r\n\r\n.pad {\r\n    padding: var(--SIZE_defaultPadding);\r\n}\r\n.hover-shade:hover{\r\n    opacity:.5;\r\n}\r\n\r\n.scene-container {\r\n    width: 100%;\r\n    height: 100%;\r\n}\r\n\r\n.section-container {\r\n    position: relative;\r\n    background-color: var(--TINT_light);\r\n}\r\n\r\n.quarter-box {\r\n    width: 25%;\r\n    aspect-ratio: 1;\r\n}\r\n\r\n.board-tile {\r\n    width: 100%;\r\n    height: 100%;\r\n    border: 1px solid;\r\n    box-sizing: border-box;\r\n}\r\n.blinder{\r\n    position:absolute;\r\n    left:0;\r\n    top:0;\r\n    width:100%;\r\n    height:100%;\r\n    background-color:black;\r\n    z-index:99999;\r\n}\r\n/*Piece Placement*/\r\n.pPlacement-tile:hover {\r\n    border: 3px solid var(--COL_altDefaultText);\r\n}\r\n\r\n.tile-has-unit{\r\n    background-color: blueviolet;\r\n    border:none;\r\n}\r\n\r\n.tile-highlight-low{\r\n    background-color: lightGreen;\r\n}\r\n\r\n.tile-highlight-high{\r\n    background-color: rgb(0,200,0);\r\n}\r\n\r\n.tile-highlight-invalid{\r\n    background-color: rgb(0,100,0);\r\n}\r\n.tile-placed-unit{\r\n    background-color: yellow;\r\n}\r\n.tile-removable-unit{\r\n    opacity: .5;\r\n}\r\n/* main game */\r\n.unit-miss{\r\n    background-color: var(--TINT_dark);\r\n}\r\n.unit-hit{\r\n    background-color: var(--TINT_green_light);\r\n}\r\n.unit-sunk{\r\n    background-color: var(--TINT_red_light);\r\n}\r\n.tile-miss{\r\n    background-color: var(--TINT_dark);\r\n}\r\n.tile-hit{\r\n    background-color: var(--TINT_green_light);\r\n}\r\n.tile-sunk{\r\n    background-color: var(--TINT_red_light);\r\n}\r\n.red-border {\r\n    border: 1px solid red;\r\n}\r\n\r\n.border {\r\n    border: 1px solid;\r\n}\r\n\r\n.border-2px {\r\n    border: 2px solid;\r\n}\r\n.text-box{\r\n    font-size:2rem;\r\n    line-height: 3rem;\r\n    background-color: var(--TINT_dark);\r\n    text-align: center;\r\n}\r\n/* Animations */\r\n.blink {\r\n    animation: 2s infinite alternate blink;\r\n}\r\n\r\n@keyframes blink {\r\n    from {\r\n        opacity: 100%;\r\n    }\r\n\r\n    33% {\r\n        opacity: 100%\r\n    }\r\n\r\n    to {\r\n        opacity: 0%;\r\n    }\r\n}"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {



/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/***/ ((module) => {



module.exports = function (url, options) {
  if (!options) {
    options = {};
  }
  if (!url) {
    return url;
  }
  url = String(url.__esModule ? url.default : url);

  // If url is already wrapped in quotes, remove them
  if (/^['"].*['"]$/.test(url)) {
    url = url.slice(1, -1);
  }
  if (options.hash) {
    url += options.hash;
  }

  // Should url be wrapped?
  // See https://drafts.csswg.org/css-values-3/#urls
  if (/["'() \t\n]|(%20)/.test(url) || options.needQuotes) {
    return "\"".concat(url.replace(/"/g, '\\"').replace(/\n/g, "\\n"), "\"");
  }
  return url;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {



module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./src/styles/reset.css":
/*!******************************!*\
  !*** ./src/styles/reset.css ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./reset.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles/reset.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_reset_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/styles/style.css":
/*!******************************!*\
  !*** ./src/styles/style.css ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../node_modules/css-loader/dist/cjs.js!./style.css */ "./node_modules/css-loader/dist/cjs.js!./src/styles/style.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {



var stylesInDOM = [];
function getIndexByIdentifier(identifier) {
  var result = -1;
  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }
  return result;
}
function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };
    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }
    identifiers.push(identifier);
  }
  return identifiers;
}
function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);
  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }
      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };
  return updater;
}
module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];
    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }
    var newLastIdentifiers = modulesToDom(newList, options);
    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];
      var _index = getIndexByIdentifier(_identifier);
      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();
        stylesInDOM.splice(_index, 1);
      }
    }
    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {



var memo = {};

/* istanbul ignore next  */
function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target);

    // Special case to return head of iframe instead of iframe itself
    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }
    memo[target] = styleTarget;
  }
  return memo[target];
}

/* istanbul ignore next  */
function insertBySelector(insert, style) {
  var target = getTarget(insert);
  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }
  target.appendChild(style);
}
module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}
module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;
  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}
module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";
  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }
  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }
  var needLayer = typeof obj.layer !== "undefined";
  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }
  css += obj.css;
  if (needLayer) {
    css += "}";
  }
  if (obj.media) {
    css += "}";
  }
  if (obj.supports) {
    css += "}";
  }
  var sourceMap = obj.sourceMap;
  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  }

  // For old IE
  /* istanbul ignore if  */
  options.styleTagTransform(css, styleElement, options.options);
}
function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }
  styleElement.parentNode.removeChild(styleElement);
}

/* istanbul ignore next  */
function domAPI(options) {
  if (typeof document === "undefined") {
    return {
      update: function update() {},
      remove: function remove() {}
    };
  }
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}
module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {



/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }
    styleElement.appendChild(document.createTextNode(css));
  }
}
module.exports = styleTagTransform;

/***/ }),

/***/ "./src/scripts/AI-mechanics copy.js":
/*!******************************************!*\
  !*** ./src/scripts/AI-mechanics copy.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   aiFactory: () => (/* binding */ aiFactory)
/* harmony export */ });
const MED_DIFF_SCALE = .5;

function aiFactory(settings) {
    //settings
    const gameboard = settings.gameboard;
    const unitArray = settings.unitArray;
    const difficulty = settings.difficulty;

    //init
    let tileArray;
    let enemyGameboard;

    const BOARD_WIDTH = gameboard.get.width();
    const BOARD_HEIGHT = gameboard.get.height();

    //objects
    function CoordObj(xCoord, yCoord) {
        this.coords = [xCoord, yCoord];
        this.x = xCoord;
        this.y = yCoord;
        this.index = xCoord + (yCoord * BOARD_WIDTH);
        const tile = tileArray[this.index];
        this.attack = () => tile.attack();
        this.getUnit = () => enemyGameboard.getUnitOnCoord(this.coords);
        this.isEqualTo = (coordObj) => {
            if (
                this.x !== coordObj.x
                || this.y !== coordObj.y
            ) return false;
            else return true;
        };
        this.isValid = () => {
            if (
                this.x < 0
                || this.y < 0
                || this.x >= BOARD_WIDTH
                || this.y >= BOARD_HEIGHT
                || previousMoves.isCoordUsed(this)
            ) return false;
            return true;
        };

        let explored = false;
        this.isExplored = () => explored;
        const exploredDirections = [];
        this.markDirectionExplored = (direction) => {
            if (!exploredDirections.includes(direction))
                exploredDirections.push(direction);
            if (
                exploredDirections.includes('up')
                && exploredDirections.includes('down')
                && exploredDirections.includes('left')
                && exploredDirections.includes('right')
            ) explored = true;
        }
        this.getCoordInDirection = (direction, markExplored = true, distance = 1) => {
            let x = this.x;
            let y = this.y;
            switch (direction) {
                case 'left': x -= distance;
                    break;
                case 'right': x += distance;
                    break;
                case 'up': y += distance;
                    break;
                case 'down': y -= distance;
                    break;
                default:
                    console.log(`${direction} is invalid.`);
                    return getRandomAttackCoord();
            }
            if (markExplored)
                this.markDirectionExplored(direction);
            return new CoordObj(x, y);
        }
    }
    const previousMoves = new function () {
        const moveArray = [];

        this.isEmpty = () => moveArray.length === 0;
        this.push = (coordObj) => {
            moveArray.push(coordObj);
            hitUnitsObj.push(coordObj);
        };
        this.pop = () => moveArray.pop();
        this.getLast = () => {
            if (!this.isEmpty())
                return moveArray[moveArray.length - 1];
        }
        this.isCoordUsed = (coordObj) => {
            for (let i = 0; i < moveArray.length; i++) {
                let move = moveArray[i];
                if (coordObj.isEqualTo(move)) {
                    return true
                }
            }
            return false;
        }


        this.noUnitsFound = () => hitUnitsObj.isEmpty();
        this.getLastHitUnitObj = () => hitUnitsObj.getLast();
        this.getHitUnitObjOf = (unit) => hitUnitsObj.getObjOf(unit);

        const hitUnitsObj = new function () {
            const hitUnitArray = [];
            //public
            this.push = (coordObj) => {
                const unit = coordObj.getUnit();
                if (!unit) return;
                const hitUnitObj = getHitUnitObj(unit);
                if (hitUnitObj) hitUnitObj.addCoordObj(coordObj);
                else hitUnitArray.push(new HitUnitObj(coordObj));
            }
            this.isEmpty = () => hitUnitArray.length <= 0;
            this.getLast = () => hitUnitArray[hitUnitArray.length - 1];
            this.getObjOf = (unit) => this.getHitUnitObjOf(unit);
            //
            function HitUnitObj(coordObj) {
                const hitCoords = [coordObj];
                let lastAddedCoord = coordObj;
                this.unit = coordObj.getUnit();
                removeSelfOnSunk();
                //public methods
                this.getPreviousCoord = () => lastAddedCoord;
                this.isInXAxis = () => {
                    if (hitCoords.length <= 1)
                        return undefined;
                    if (hitCoords[0].x === hitCoords[1].x)
                        return false;
                    else return true;
                }
                this.addCoordObj = (coordObj) => {
                    hitCoords.push(coordObj);
                    lastAddedCoord = coordObj;
                    sortHitCoords();
                    removeSelfOnSunk();
                }
                this.getFirstCoord = () => hitCoords[0];
                this.getLastCoord = () => hitCoords[hitCoords.length - 1];
                this.getNextGuess = (startCoordObj = hitCoords[0]) => {
                    let nextCoordObj = new CoordObj(-1, -1);
                    let inXAxis = this.isInXAxis();
                    if (inXAxis === undefined) {
                        let direction = directionObj.getRandom();
                        for (let i = 0; i < 4; i++) {
                            direction = directionObj.getNext(direction, i);
                            nextCoordObj = startCoordObj.getCoordInDirection(direction);
                            if (nextCoordObj.isValid()) return nextCoordObj;
                        }
                    }
                    let direction = directionObj.getRandom(inXAxis);
                    nextCoordObj = startCoordObj.getCoordInDirection(direction);
                    if (nextCoordObj.isValid()) return nextCoordObj;
                    direction = directionObj.getReverseOf(direction);
                    nextCoordObj = startCoordObj.getCoordInDirection(direction);
                    if (nextCoordObj.isValid()) return nextCoordObj;
                    return this.getNextGuess(this.getLastCoord());
                }
                //HitUnitObj priv
                const getIndex = () => {
                    for (let i = 0; i < hitUnitArray.length; i++) {
                        let unit = hitUnitArray[i].unit;
                        if (this.unit.isEqualTo(unit)) return i;
                    }
                    console.log('Should not appear');
                }
                function removeSelfOnSunk() {
                    if (coordObj.getUnit().get.health() <= 1)
                        hitUnitArray.splice(getIndex(), 1);
                }
                const sortHitCoords = () => {
                    if (hitCoords.length <= 1) return;
                    hitCoords.sort((a, b) => {
                        if (this.isInXAxis()) {
                            return a.x - b.x;
                        } else {
                            return a.y - b.y;
                        }
                    })
                }
            }
            // hitObj priv

            function getHitUnitObj(unit) {
                for (let i = 0; i < hitUnitArray.length; i++) {
                    let hitUnitObj = hitUnitArray[i];
                    let unit2 = hitUnitObj.unit;
                    if (unit.isEqualTo(unit2)) return hitUnitObj;
                }
                return false;
            }
        }
    }

    const attackObj = new function () {
        this.sendAttack = () => {
            const coordObj = getAttackCoordObj();
            previousMoves.push(coordObj);
            coordObj.attack();
        }

        function getAttackCoordObj() {
            let hitUnitObj = previousMoves.getLastHitUnitObj();
            switch (difficulty) {
                case 'easy':
                    return getRandomAttackCoord();
                    break;
                case 'medium':
                    if (previousMoves.noUnitsFound())
                        return getRandomAttackCoord();
                    return hitUnitObj.getNextGuess();
                    break;
                case 'hard': //could add to check space around randomCoord to see if valid for unit lengths
                    if (previousMoves.noUnitsFound()) {
                        let nextGuess = getRandomAttackCoord();
                        if (!nextGuess.getUnit())
                            nextGuess = getRandomAttackCoord();
                        return getRandomAttackCoord();
                    }
                    let nextGuess = hitUnitObj.getNextGuess();
                    if (!nextGuess.getUnit())
                        nextGuess = hitUnitObj.getNextGuess();
                    return nextGuess;
                    break;
                default:
                    console.log(`Invalid difficulty: ${difficulty}`);
                    return getRandomAttackCoord();
            }
        }

        function getRandomAttackCoord() {
            let x = Math.round(Math.random() * (BOARD_WIDTH - 1));
            let y = Math.round(Math.random() * (BOARD_HEIGHT - 1));
            let coordObj = new CoordObj(x, y);
            while (!coordObj.isValid()) {
                x++;
                if (x >= BOARD_WIDTH - 1) {
                    x = 0;
                    y++;
                }
                if (y >= BOARD_HEIGHT - 1)
                    y = 0;
                coordObj = new CoordObj(x, y);
            }
            return coordObj;
        }
    }
    const directionObj = new function () {
        const directions = ['left', 'up', 'right', 'down'];
        this.getRandom = (inXAxis = undefined) => {
            let index;
            const rand = Math.random();
            switch (inXAxis) {
                case undefined:
                    index = Math.round(rand * 3);
                    break;
                case true: //0 or 2
                    index = Math.round(rand) * 2;
                    break;
                case false: // 1 or 3
                    index = (Math.round(rand) * 2) + 1
                    break;
            }
            return directions[index];
        }
        this.getReverseOf = (direction) => {
            const index = (directions.indexOf(direction) + 2) % 4;
            return directions[index];
        }
        this.getNext = (direction, distance = 1) => {
            if (distance === 0)
                return direction;
            let index = directions.indexOf(direction);
            if (index < 0)
                return false;
            index = (index + distance) % 4;
            return directions[index];
        }
        this.isValid = (direction) => {
            return directions.includes(direction);
        }
    }


    //return object
    const aiObj = {
        sendAttack: () => {
            if (tileArray && enemyGameboard)
                attackObj.sendAttack();
            else console.log('Please set tileArray and enemyGameboard.');
        },
        placeShips: () => {
            const boardHeight = gameboard.get.height();
            const boardWidth = gameboard.get.width();
            unitArray.forEach(unit => {
                let x, y, rotated;
                do {
                    x = Math.round(Math.random() * (boardWidth - 1));
                    y = Math.round(Math.random() * (boardHeight - 1));
                    rotated = Math.random() < .5;
                } while (!gameboard.placeUnit(unit, [x, y], rotated))
            })

        },
        setTileArray: (tileArr) => tileArray = tileArr,
        setEnemyGameboard: (enemyGB) => enemyGameboard = enemyGB,
    }

    return aiObj;
}







/***/ }),

/***/ "./src/scripts/class-manager.js":
/*!**************************************!*\
  !*** ./src/scripts/class-manager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CLASSES: () => (/* binding */ CLASSES)
/* harmony export */ });
const CLASSES = {
    unit: 'tile-has-unit',
    lowHighlight: 'tile-highlight-low',
    highHighlight: 'tile-highlight-high',
    invalidHighlight: 'tile-highlight-invalid',
    removableUnit: 'tile-removable-unit',
    hoverShade: 'hover-shade',

    unitHit:'unit-hit',
    unitMiss:'unit-miss',
    unitSunk:'unit-sunk',

    tileHit:'tile-hit',
    tileMiss:'tile-miss',
    tileSunk:'tile-sunk',
};



/***/ }),

/***/ "./src/scripts/game-state.js":
/*!***********************************!*\
  !*** ./src/scripts/game-state.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   setDummyUnits: () => (/* binding */ setDummyUnits)
/* harmony export */ });
/* harmony import */ var _AI_mechanics_copy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AI-mechanics copy */ "./src/scripts/AI-mechanics copy.js");
/* harmony import */ var _gameboard_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gameboard-manager */ "./src/scripts/gameboard-manager.js");
/* harmony import */ var _scene_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scene-manager */ "./src/scripts/scene-manager.js");




const BOARD_WIDTH = 7;
const BOARD_HEIGHT = 7;
const PIECE_COUNT = 5;
const PIECE_LENGTH_ARRAY = [0, 0, 1, 1, 1, 1, 0, 0]; //index == piece length  value == piece count of said length
const DEFAULT_DIFFICULTY = 'medium';
let _isSinglePlayer;

let _currentPlayer = 'p1';
let _isGameOver = false;

//todo: change gamestate get/sets to individual objects with get/set and all references
const gameState = {
    get: {
        game: {
            isSinglePlayer: () => _isSinglePlayer,
            boardWidth: () => BOARD_WIDTH,
            boardHeight: () => BOARD_HEIGHT,
            pieceCount: () => PIECE_COUNT,
            isGameOver: () => _isGameOver,
        },
        scene: {
            currentPlayer: () => _currentPlayer,
        },
    },
    set: {
        game: {
            isSinglePlayer: (bool) => {
                if (_isSinglePlayer !== undefined) {
                    console.log(`Can not change number of players. Returning.`);
                    return;
                }
                if ((bool !== true)
                    && bool !== false) {
                    console.log(`${bool} is not boolean. Returning.`);
                    return;
                }
                _isSinglePlayer = bool;
            },
            isGameOver:(bool) => {_isGameOver = bool},
        },
        scene: {
            swapPlayers: () => {
                if (_currentPlayer === 'p1') _currentPlayer = 'p2';
                else _currentPlayer = 'p1';
                return _currentPlayer;
            },
            setCurrentPlayer: (playerRef) => {
                if (playerRef !== 'p1'
                    && playerRef !== 'p2') return console.log(`Invalid playerRef: ${playerRef}`);
                _currentPlayer = playerRef;
            }
        },
    },
    p1: _generatePlayerObj('p1'),
    p2: _generatePlayerObj('p2'),
    p0: { //here for intellisense
        get: {
            player: () => {},
            units: () => {},
            gameboard: () => {},
        },
        set: {
            player: () => {},
            gameboard: () => {},
        },
    },
};

function _generatePlayerObj(playerRef) {

    let _player;
    const _gameboard = new _gameboard_manager__WEBPACK_IMPORTED_MODULE_1__.Gameboard(BOARD_WIDTH, BOARD_HEIGHT);
    const _units = _createUnitArray();
    const _ai = (0,_AI_mechanics_copy__WEBPACK_IMPORTED_MODULE_0__.aiFactory)({gameboard:_gameboard,unitArray:_units, difficulty: DEFAULT_DIFFICULTY});
    const playerObj = {
        get: {
            player: () => _player !== undefined ? _player : playerRef,
            units: () => _units,
            gameboard: () => _gameboard,
            playerRef: () => playerRef,
        },
        set: {
            player: (player) => {
                if (_player !== undefined) return console.log('player already set. Returning.');
                _player = player;
            },
            gameboard: (gameboard) => {
                if (_gameboard !== undefined) return console.log('gameboard already set. Returning.');
                _gameboard = gameboard;
            },
        },
        ai:{
            placeShips: _ai.placeShips,
            sendAttack: _ai.sendAttack,
            setTileArray: _ai.setTileArray,
            setEnemyGameboard: _ai.setEnemyGameboard,
        },
    };
    return playerObj;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (gameState);

function _createUnitArray() {
    const unitArray = [];
    for (let unitLength = 0; unitLength < PIECE_LENGTH_ARRAY.length; unitLength++) {
        for (let unitCount = PIECE_LENGTH_ARRAY[unitLength]; unitCount > 0; unitCount--) {
            unitArray.push((0,_gameboard_manager__WEBPACK_IMPORTED_MODULE_1__.unitFactory)(unitLength));
        }
    }
    return unitArray;
}

function setDummyUnits(){
    console.log('setting dummy units');
    const gameboardArray = [
        gameState.p1.get.gameboard(),
        gameState.p2.get.gameboard()
    ];
    let offset = 1;
    let units = gameState.p1.get.units();
    gameboardArray.forEach(gb =>{
        if(gb === gameState.p1.get.gameboard()){
            units = gameState.p1.get.units()
        }else{
            units = gameState.p2.get.units()
        }
        for(let i = offset; i < units.length + offset; i++){
            gb.placeUnit(units[i - offset],[0,i]);
        }
        offset++;
    })
}


/***/ }),

/***/ "./src/scripts/gameboard-manager.js":
/*!******************************************!*\
  !*** ./src/scripts/gameboard-manager.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Gameboard: () => (/* binding */ Gameboard),
/* harmony export */   unitFactory: () => (/* binding */ unitFactory)
/* harmony export */ });
function Gameboard(width = 10, height = 10) {
    let _unitsRemaining = 0;
    const boardSize = width * height;
    const _boardArray = [];
    for (let i = 0; i < boardSize; i++) _boardArray.push(false);
    const _hitArray = [];
    for (let i = 0; i < boardSize; i++) _hitArray.push(false);
    this.get = {
        unitsRemaining: () => { return _unitsRemaining },
        boardArray: () => { return _boardArray },
        hitArray: () => { return _hitArray },
        width: () => { return width },
        height: () => { return height },
    }
    this.placeUnit = (unit, coord, rotated) => {
        if (coord.x !== undefined) coord = [coord.x, coord.y]; //allows coord obj instead of array
        for (let i = 0; i < unit.get.length(); i++) {
            let j = rotated ?
                get2DIndex(coord[0], coord[1] + i) :
                get2DIndex(coord[0] + i, coord[1]);
            if (j === false) return false;
            if (_boardArray[j]) return false;
        }
        for (let i = 0; i < unit.get.length(); i++) {
            let j = rotated ?
                get2DIndex(coord[0], coord[1] + i) :
                get2DIndex(coord[0] + i, coord[1]);
            _boardArray[j] = unit;
        }
        _unitsRemaining++;
        return true;
    }
    this.removeUnit = (unit) => {
        _boardArray.forEach(value => { if (value === unit) value = false; })
    }
    this.getUnitOnCoord = (coord) => {
        const index = get2DIndex(coord);
        if (_boardArray[index]) return _boardArray[index];
        return false;
    }
    this.receiveAttack = (coord) => {
        const i = get2DIndex(coord);
        if (_hitArray[i]) return false;
        _hitArray[i] = true;

        const unit = _boardArray[i];
        if (!unit) return 'miss';
        unit.hit();
        if (unit.isSunk()) {
            _unitsRemaining--;
            return 'sunk';
        }
        return 'hit';
    }
    this.isGameOver = () => { return _unitsRemaining <= 0 }

    function get2DIndex(x, y) {
        let a, b;
        if (x.x !== undefined) { //Allows using coordObj
            x = [x.x, x.y];
        }
        if (x[0] === undefined) {
            a = x;
            b = y;
        } else {
            a = x[0];
            b = x[1];
        }
        if (a >= width)
            return false;
        if (b >= height)
            return false
        if ((a < 0) ||
            (b < 0))
            return false;
        return a * width + b;
    }
}

let _unitID = 1000;
function unitFactory(length) {
    const _id = _unitID++;
    const _length = length;
    let _hits = 0;

    const unit = {
        get: {
            id: () => _id,
            length: () => _length,
            health: () => _length - _hits,
        },
        hit: () => { _hits++; },
        isSunk: () => { return (_hits >= _length) },
        isEqualTo: (unit) => _id === unit.get.id(),
    }
    return unit;
}





/***/ }),

/***/ "./src/scripts/player-factory.js":
/*!***************************************!*\
  !*** ./src/scripts/player-factory.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function playerFactory(name, type = 'human') {
    let _games = 0;
    let _wins = 0;
    let _streak = 0;
    const player = {
        get: {
            name: () => { return name; },
            type: () => { return type; },
            games: () => {return _games},
            wins: ()=>{return _wins},
            streak: ()=>{return _streak},
        },
        addGamePlayed:(wasWon)=>{
            _games++;
            if(wasWon){
                _wins++;
                _streak++;
            }
            else _streak = 0;
        },
    }

    return player;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (playerFactory);

/***/ }),

/***/ "./src/scripts/scene-manager.js":
/*!**************************************!*\
  !*** ./src/scripts/scene-manager.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addGridBoardProperties: () => (/* binding */ addGridBoardProperties),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   generateGameTiles: () => (/* binding */ generateGameTiles),
/* harmony export */   initScene: () => (/* binding */ initScene)
/* harmony export */ });
/* harmony import */ var _game_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./game-state */ "./src/scripts/game-state.js");
/* harmony import */ var _scenes_blinder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scenes/blinder */ "./src/scripts/scenes/blinder.js");
/* harmony import */ var _scenes_title_screen__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scenes/title-screen */ "./src/scripts/scenes/title-screen.js");
/* harmony import */ var _scenes_player_select__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scenes/player-select */ "./src/scripts/scenes/player-select.js");
/* harmony import */ var _scenes_piece_placement__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scenes/piece-placement */ "./src/scripts/scenes/piece-placement.js");
/* harmony import */ var _scenes_main_game__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scenes/main-game */ "./src/scripts/scenes/main-game.js");






//import playerFactory from "./player-factory";
//import gameState from "./game-state";
//import gamePieces from "./game-pieces";

let scenes = {
    main: {},
    p1: {},
    p2: {},
};
const blinderObj = (0,_scenes_blinder__WEBPACK_IMPORTED_MODULE_1__["default"])();
let currentScene;
const gameWindow = document.getElementById('gameWindow');
const sceneManager = {
    initializeScenes: initializeScenes,
    getScenes: ()=>scenes,
    getCurrentScene: ()=>currentScene,
    loadScene,
    addBlinder,
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sceneManager);


function loadScene(sceneNode) {
    if (currentScene) currentScene.remove();
    if (!sceneNode) {
        console.log(`${{ sceneNode }} is not a valid node.`);
        return;
    }
    gameWindow.appendChild(sceneNode);
    if(sceneNode.sceneOnLoad) sceneNode.sceneOnLoad();
    currentScene = sceneNode;
}

function initializeScenes() {
    scenes.main.titleScreen = (0,_scenes_title_screen__WEBPACK_IMPORTED_MODULE_2__["default"])();
    scenes.main.playerSelect = (0,_scenes_player_select__WEBPACK_IMPORTED_MODULE_3__["default"])();
    scenes.p1.piecePlacement = (0,_scenes_piece_placement__WEBPACK_IMPORTED_MODULE_4__["default"])(); 
    scenes.main.game = (0,_scenes_main_game__WEBPACK_IMPORTED_MODULE_5__["default"])();
    //initMainGame();
    //initGameOver();
}
function addBlinder(text = undefined){
    gameWindow.appendChild(blinderObj.scene);
    if(text !== undefined){
        blinderObj.setText(text);
    }
}

//exports



function initScene(templateID) {
    let template = document.getElementById(templateID);
    if (!template) {
        console.log(`${templateID} is an invalid template ID.`)
        return false;
    }
    return template.content.firstElementChild.cloneNode(true);
}
function generateGameTiles(parentNode) {
    const tileArr = [];
    const numTilesX = _game_state__WEBPACK_IMPORTED_MODULE_0__["default"].get.game.boardWidth();
    const numTilesY = _game_state__WEBPACK_IMPORTED_MODULE_0__["default"].get.game.boardHeight();
    if(parentNode) addGridBoardProperties(parentNode);
    for (let y = 0; y < numTilesY; y++) {
        for (let x = 0; x < numTilesX; x++) {
            const tile = document.createElement('div');
            tile.classList.add('board-tile');
            tile.setAttribute('posX',x);
            tile.setAttribute('posY',y);
            if(parentNode) parentNode.appendChild(tile);
            tileArr.push(tile);
        }
    }
    return tileArr;
}

function addGridBoardProperties(node){
    const width = _game_state__WEBPACK_IMPORTED_MODULE_0__["default"].get.game.boardWidth();
    const height = _game_state__WEBPACK_IMPORTED_MODULE_0__["default"].get.game.boardHeight();
    node.style.display = 'grid';
    node.style.gridTemplate = `repeat(${height}, 1fr) / repeat(${width}, 1fr)`;
}

/***/ }),

/***/ "./src/scripts/scenes/blinder.js":
/*!***************************************!*\
  !*** ./src/scripts/scenes/blinder.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scene_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scene-manager */ "./src/scripts/scene-manager.js");

function initBlinder(){
    const scene = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_0__.initScene)('TEMPLATE_blinder');
    const textBox = scene.querySelector("[blinderID='textBox']");
    scene.addEventListener('click',(e)=>{
        e.preventDefault(); //untested, should be fine
        setText('');
        scene.remove();
    })
    function setText(text){
        textBox.textContent = text;
    }
    return {scene, setText}
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initBlinder);

/***/ }),

/***/ "./src/scripts/scenes/main-game.js":
/*!*****************************************!*\
  !*** ./src/scripts/scenes/main-game.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _class_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../class-manager */ "./src/scripts/class-manager.js");
/* harmony import */ var _game_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game-state */ "./src/scripts/game-state.js");
/* harmony import */ var _scene_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../scene-manager */ "./src/scripts/scene-manager.js");





////////////////////Exports///////////////////////////
const scene = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_2__.initScene)('TEMPLATE_main-game');
scene.sceneOnLoad = () => {
    gameWindows.p1 = {
        offense: new OffenseGameWindow(playerObjs.p1),
        defense: new DefenseGameWindow(playerObjs.p1)
    };
    gameWindows.p2 = {
        offense: new OffenseGameWindow(playerObjs.p2),
        defense: new DefenseGameWindow(playerObjs.p2)
    }

    gameWindows.p1.defense.displayUnits();
    gameWindows.p2.defense.displayUnits();
    _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].set.scene.setCurrentPlayer('p1');
    textBoxObj.displayPlayerTurn();
    if (_game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.game.isSinglePlayer()) setDisplayObj.singplePlayer();
    else setDisplayObj.multiplayer();

    _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].p1.ai.setTileArray(gameWindows.p1.offense.getTileArray());
    _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].p1.ai.setEnemyGameboard(_game_state__WEBPACK_IMPORTED_MODULE_1__["default"].p2.get.gameboard());
    _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].p2.ai.setTileArray(gameWindows.p2.offense.getTileArray());
    _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].p2.ai.setEnemyGameboard(_game_state__WEBPACK_IMPORTED_MODULE_1__["default"].p1.get.gameboard());
}
function initMainGameScene() {
    return scene;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initMainGameScene);
//////////////////////////////////////////////////////

//static
const attackStates = {
    hit: 'hit',
    miss: 'miss',
    sunk: 'sunk',
    error: false,
}

//data objects
const playerObjs = {
    p1: _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].p1,
    p2: _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].p2,
}
const gameWindows = {
    p1: {
        offense: new OffenseGameWindow(playerObjs.p1),
        defense: new DefenseGameWindow(playerObjs.p1)
    },
    p2: {
        offense: new OffenseGameWindow(playerObjs.p2),
        defense: new DefenseGameWindow(playerObjs.p2)
    }
}

// function objects
const setDisplayObj = new function () {
    const gameBox1 = scene.querySelector("[gameID='gameBox-left']");
    const gameBox2 = scene.querySelector("[gameID='gameBox-right']");
    (0,_scene_manager__WEBPACK_IMPORTED_MODULE_2__.addGridBoardProperties)(gameBox1);
    (0,_scene_manager__WEBPACK_IMPORTED_MODULE_2__.addGridBoardProperties)(gameBox2);
    // this.p1 = () => {
    //     _first(gameWindows.p1.defense);
    //     _second(gameWindows.p1.offense);
    // }
    // this.p2 = () => {
    //     _first(gameWindows.p2.defense);
    //     _second(gameWindows.p2.offense);
    // }
    this.singplePlayer = () => {
        _first(gameWindows.p1.defense);
        _second(gameWindows.p1.offense);
    }
    this.multiplayer = () => {
        _first(gameWindows.p1.offense);
        _second(gameWindows.p2.offense);
    }
    this.custom = (first, second) => {
        _first(first);
        _second(second);
    }
    const _first = (gameWindow) => {
        const tileArray = gameWindow.getTileNodeArray();
        _replaceTilesIn(gameBox1, tileArray)
    }
    const _second = (gameWindow) => {
        const tileArray = gameWindow.getTileNodeArray();
        _replaceTilesIn(gameBox2, tileArray);
    }
    function _replaceTilesIn(gameBox, tileArray) {
        gameBox.textContent = '';
        tileArray.forEach(tile => {
            gameBox.appendChild(tile);
        })
    }
}
const textBoxObj = new function () {
    const textBox = scene.querySelector("[gameID='textBox']");
    this.clearText = () => { textBox.textContent = '' };
    this.setText = (text) => { textBox.textContent = text };
    this.displayPlayerTurn = () => {
        const pRef = _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.scene.currentPlayer();
        const name = playerObjs[pRef].get.player().get.name();
        this.setText(`${name}'s turn.`)
    }
    this.turnResult = (result) => {
        this.setText(result);
    }
    this.addNewLineText = (text) => {
        textBox.innerHTML += '<br>' + text;
    }
}
function DefenseGameWindow(playerObj) {
    //init
    const tileNodes = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_2__.generateGameTiles)();
    const tiles = getTileObjArray(tileNodes);
    const gameboard = playerObj.get.gameboard();
    const enemyRef = getEnemyPlayerRef(playerObj);
    const unitTileArr = [];

    this.getTileNodeArray = () => tileNodes;
    this.displayUnits = () => {
        tiles.forEach(tile => {
            const coord = tile.getCoord();
            const unit = gameboard.getUnitOnCoord(coord);
            if (unit) tile.addClass(_class_manager__WEBPACK_IMPORTED_MODULE_0__.CLASSES.unit);
        })
    }
    this.receiveAttack = (coord) => {
        const unit = gameboard.getUnitOnCoord(coord);
        const attackState = gameboard.receiveAttack(coord);
        const index = getIndexFromCoord(coord);
        const tile = tiles[index];

        switch (attackState) {
            case attackStates.hit:
                tile.addClass(_class_manager__WEBPACK_IMPORTED_MODULE_0__.CLASSES.unitHit);
                pushUnitTileArr(unit, tile)
                break;
            case attackStates.miss:
                tile.addClass(_class_manager__WEBPACK_IMPORTED_MODULE_0__.CLASSES.unitMiss);
                break;
            case attackStates.sunk:
                tile.addClass(_class_manager__WEBPACK_IMPORTED_MODULE_0__.CLASSES.unitSunk);
                const tileArr = getUnitTileArr(unit).tileArr;
                tileArr.forEach(tile => { tile.addClass(_class_manager__WEBPACK_IMPORTED_MODULE_0__.CLASSES.unitSunk); });
                return new AttackObj(attackState, tileArr);
                ///
                break;
            case attackStates.error:
                break;
            default:
                console.log(`Attack state ${attackState} was unexpected.`);
        }
        return new AttackObj(attackState);
    }
    //private fn
    function AttackObj(attackState, affectedTiles) {
        const affectedIndexes = [];
        if (affectedTiles)
            affectedTiles.forEach(tile => {
                affectedIndexes.push(tile.getIndex())
            })
        this.attackState = attackState;
        this.affectedIndexes = affectedIndexes;
    }
    function UnitTileObj(unit, tile) {
        const tileArr = [tile];
        this.unit = unit;
        this.tileArr = tileArr;
        this.pushTile = (tile) => { tileArr.push(tile) };
    }
    function pushUnitTileArr(unit, tile) {
        for (let i = 0; i < unitTileArr.length; i++)
            if (unit === unitTileArr[i].unit)
                return unitTileArr[i].pushTile(tile);
        unitTileArr.push(new UnitTileObj(unit, tile));
    }
    function getUnitTileArr(unit) {
        for (let i = 0; i < unitTileArr.length; i++)
            if (unitTileArr[i].unit === unit)
                return unitTileArr[i];
    }
}
function OffenseGameWindow(playerObj) {
    //init
    const tileNodes = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_2__.generateGameTiles)();
    const tiles = getTileObjArray(tileNodes);
    const gameboard = playerObj.get.gameboard();
    const enemyRef = getEnemyPlayerRef(playerObj);
    const enemyGameboard = _game_state__WEBPACK_IMPORTED_MODULE_1__["default"][enemyRef].get.gameboard();
    //event listeners
    tiles.forEach(tile => {
        const node = tile.getNode();
        node.addEventListener('click', tileOnClick)
        tile.attack = tileOnClick;

        function tileOnClick(e) {
            if (_game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.scene.currentPlayer() == enemyRef
                || _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.game.isGameOver()) return;

            const coord = tile.getCoord();
            const attackObj = sendAttack(coord);

            switch (attackObj.attackState) {
                case attackStates.hit:
                    tile.addClass(_class_manager__WEBPACK_IMPORTED_MODULE_0__.CLASSES.tileHit);
                    break;
                case attackStates.miss:
                    tile.addClass(_class_manager__WEBPACK_IMPORTED_MODULE_0__.CLASSES.tileMiss);
                    break;
                case attackStates.sunk:
                    tile.addClass(_class_manager__WEBPACK_IMPORTED_MODULE_0__.CLASSES.tileSunk);
                    attackObj.affectedIndexes.forEach(index => {
                        const tile = tiles[index];
                        tile.addClass(_class_manager__WEBPACK_IMPORTED_MODULE_0__.CLASSES.tileSunk)
                    });
                    break;
                case attackStates.error:
                    return;
                    break;
                default:
                    console.log(`Attack state ${attackState} was unexpected.`);
            }
            if (enemyGameboard.isGameOver()) {
                _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].set.game.isGameOver(true);
                _game_state__WEBPACK_IMPORTED_MODULE_1__["default"][enemyRef].get.player().addGamePlayed(false);
                playerObj.get.player().addGamePlayed(true);
                textBoxObj.setText('You win!');
            }
            else {
                textBoxObj.turnResult(attackObj.attackState);
                nextTurn();
            }
            return attackObj.attackState;
        }
    })

    //public fn
    this.getTileNodeArray = () => tileNodes;
    this.getTileFromIndex = (index) => tiles[index];
    this.getTileArray = () => tiles;
    //private fn
    const sendAttack = (coords) => {
        return gameWindows[enemyRef].defense.receiveAttack(coords);
    }
}
function getTileObjArray(tileNodeArray) {
    const tileObjArray = [];

    for (let i = 0; i < tileNodeArray.length; i++)
        tileObjArray.push(new TileObj(tileNodeArray[i], i));

    return tileObjArray;
    //private
    function TileObj(tileNode, index) {
        const coordObj = {
            x: +tileNode.getAttribute('posX'),
            y: +tileNode.getAttribute('posY')
        }
        this.getNode = () => tileNode;
        this.getCoord = () => coordObj;
        this.getIndex = () => index;
        const tempClasses = [];
        this.addTempClass = (className) => {
            tempClasses.push(className);
            tileNode.classList.add(className);
        }
        this.removeTempClasses = () => {
            while (tempClasses.length > 0)
                tileNode.classList.remove(tempClasses.pop());
        }
        this.addClass = (className) => tileNode.classList.add(className);
    }
}
//
function getEnemyPlayerRef(playerObj) {
    let playerRef = playerObj.get.playerRef();
    return playerRef === 'p1' ? 'p2' : 'p1';
}
function getPlayerName(playerObj) {
    if (playerObj === 'p1') playerObj = _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].p1;
    if (playerObj === 'p2') playerObj = _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].p2;
    return playerObj.get.player().get.name();
}
function getIndexFromCoord(coord) {
    return coord.x + (coord.y * _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.game.boardWidth());
}
//
function nextTurn() {
    const playerRef = _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].set.scene.swapPlayers();
    if (_game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.game.isSinglePlayer()) {
        if (playerRef === 'p2') {
            _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].p2.ai.sendAttack();
        } else {

        }
    }
    textBoxObj.addNewLineText(`${_game_state__WEBPACK_IMPORTED_MODULE_1__["default"][playerRef].get.player().get.name()}'s turn.`)
}

/***/ }),

/***/ "./src/scripts/scenes/piece-placement.js":
/*!***********************************************!*\
  !*** ./src/scripts/scenes/piece-placement.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scene_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scene-manager */ "./src/scripts/scene-manager.js");
/* harmony import */ var _game_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../game-state */ "./src/scripts/game-state.js");
/* harmony import */ var _class_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../class-manager */ "./src/scripts/class-manager.js");





//export scene to sceneManager
function initPiecePlacement() {
    return createScene('p1');
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initPiecePlacement);

//internal workings start here
const PIECE_COUNT = _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.game.pieceCount();
const BOARD_WIDTH = _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.game.boardWidth();
const BOARD_HEIGHT = _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.game.boardHeight();

const STATES = {
    current: 1,
    pickTile: 1,
    placeUnit: 2,
}

function createScene(playerRef) {
    //generate scene node from template
    const scene = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_0__.initScene)('TEMPLATE_piece-placement');
    //generate gameTiles and add properties
    const gameTiles = createGameTilesObj();
    //other scoped vars
    const playerObj = _game_state__WEBPACK_IMPORTED_MODULE_1__["default"][playerRef];
    const unitObj = createUnitObj(playerObj.get.units());
    const placedUnitsObj = new PlacedUnitsObj();

    return scene;
    //
    function createGameTilesObj() {
        const _submitElement = scene.querySelector('[pPlacementID="submit"]');
        const _quickPlayElement = scene.querySelector('[pPlacementID="quickPlay"]');
        const _gameBoxElement = scene.querySelector('[pPlacementID="gameBox"]');
        const _tileNodeArray = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_0__.generateGameTiles)(_gameBoxElement);
        const tileObjs = [];


        //removed }  here -in case that was the wrong one

        let selectedTile;
        //tile-class object arrays
        const activeHoverTiles = [];
        // const activeUnitTiles = [];

        for (let i = 0; i < _tileNodeArray.length; i++) {
            tileObjs.push(_tileFactory(_tileNodeArray[i], i));
        }
        return tileObjs;

        //private functions
        function _tileFactory(tileNode, index) {
            let currentUnit;
            const coords = {
                x: +tileNode.getAttribute('posX'),
                y: +tileNode.getAttribute('posY')
            }
            //tile object creation
            const tile = {
                getNode: () => tileNode,
                getCoordObj: () => coords,
                getCoordArray: () => [coords.x, coords.y],
                getIndex: () => index,
                unit: {
                    place: (unit) => {
                        if (currentUnit) return false;
                        currentUnit = unit;
                        placedUnitsObj.pushUnit(unit, tile);
                        tileNode.classList.add('tile-placed-unit');
                        unitObj.setUnitPlaced(unit);
                    },
                    removeFullUnit: (unit) => {
                        let tileArr = placedUnitsObj.getTileArrayFromPlacedUnit(unit);
                        tileArr.forEach(tile => {
                            tile.unit.removeSelfUnit();
                        });
                        placedUnitsObj.removeUnit(unit);
                    },
                    removeSelfUnit: () => {
                        currentUnit = undefined;
                        tileNode.classList.remove('tile-placed-unit');
                    },
                    getUnit: () => currentUnit,
                },
                nextTile: {
                    up: () => tileObjs[index - BOARD_WIDTH],
                    down: () => tileObjs[index + BOARD_WIDTH],
                    left: () => {
                        if (coords.x - 1 < 0) return false;
                        return tileObjs[index - 1];
                    },
                    right: () => {
                        if (coords.x + 1 >= BOARD_WIDTH) return false;
                        return tileObjs[index + 1];
                    },
                },
                highlight: {
                    selectable: () => { addHighlight(activeHoverTiles, _class_manager__WEBPACK_IMPORTED_MODULE_2__.CLASSES.lowHighlight); },
                    invalid: () => { addHighlight(activeHoverTiles, _class_manager__WEBPACK_IMPORTED_MODULE_2__.CLASSES.invalidHighlight); },
                    validPlaceUnit: () => { addHighlight(activeHoverTiles, _class_manager__WEBPACK_IMPORTED_MODULE_2__.CLASSES.highHighlight) },
                    removableUnit: () => { addHighlight(activeHoverTiles, _class_manager__WEBPACK_IMPORTED_MODULE_2__.CLASSES.removableUnit); },
                },
                selectedTile: {
                    unSelect: () => {
                        if (!selectedTile) return console.log('no selected tile');
                        selectedTile.getNode().classList.remove(_class_manager__WEBPACK_IMPORTED_MODULE_2__.CLASSES.highHighlight);
                        selectedTile = undefined;
                    },
                    selectThis: () => {
                        if (selectedTile) return false;
                        if (tile.unit.getUnit()) return false;
                        selectedTile = tile;
                        tileNode.classList.add(_class_manager__WEBPACK_IMPORTED_MODULE_2__.CLASSES.highHighlight);
                        return true;
                    },
                },
            }
            //event listeners
            tileNode.addEventListener('mouseover', (e) => {
                switch (STATES.current) {
                    case STATES.pickTile:
                        if (currentUnit) {
                            highlightUnit(currentUnit);
                        } else highlightAllplacements();
                        break;
                    case STATES.placeUnit:
                        highlightCurrentPlacement();
                        break;
                    default: console.log(`Invalid state: ${STATES.current}.`);
                }
            });

            tileNode.addEventListener('mouseleave', (e) => {
                removeHighlights(activeHoverTiles);
            });
            tileNode.addEventListener('click', (e) => {
                switch (STATES.current) {
                    case STATES.pickTile:
                        if (currentUnit) {
                            tile.unit.removeFullUnit(currentUnit);
                            highlightAllplacements();
                        }
                        else if (tile.selectedTile.selectThis())
                            STATES.current = STATES.placeUnit;
                        break;
                    case STATES.placeUnit:
                        if (tile.unit.getUnit()) return;
                        if (tile === selectedTile) { //clicking selectedTile removes it
                            tile.selectedTile.unSelect();
                            removeHighlights(activeHoverTiles);
                            STATES.current = STATES.pickTile;
                            highlightAllplacements();
                            break;
                        }
                        if (!placeUnit()) break;
                        tile.selectedTile.unSelect();
                        if (!tile.unit.getUnit()) highlightAllplacements()
                        STATES.current = STATES.pickTile;

                        break;
                    default: console.log(`Invalid state: ${STATES.current}.`);
                }
            });

            _submitElement.addEventListener('click', submitScene);
            _quickPlayElement.addEventListener('click',submitQuickSelect);

            //highlights in all 4 directions for a distance of the current maxLength
            function highlightAllplacements() {
                if (unitObj.noUnitsAvailable()) return;
                tile.highlight.selectable();

                const directionTiles = [
                    new DirecionTileObj('up'),
                    new DirecionTileObj('down'),
                    new DirecionTileObj('left'),
                    new DirecionTileObj('right')
                ]
                const minLength = unitObj.getMinLength();
                const maxLength = unitObj.getMaxLength();

                for (let i = 2; i <= maxLength; i++)
                    directionTiles.forEach(obj => { obj.highlightNext(i); })

                function DirecionTileObj(direction) {
                    const tileArr = [tile];
                    let tileObj = tile;

                    this.highlightNext = (length) => {
                        if (!tileObj) return;
                        tileObj = tileObj.nextTile[direction]();

                        if (!tileObj || tileObj.unit.getUnit()) {
                            if (tileArr.length === 0) return tileObj = false;

                            for (length--; length >= minLength && !unitObj.getUnitOfLength(length); length--) {
                                tileObj = tileArr.pop();
                                tileObj.getNode().classList.remove(_class_manager__WEBPACK_IMPORTED_MODULE_2__.CLASSES.invalidHighlight);
                            }
                            return tileObj = false;
                        }
                        if (unitObj.getUnitOfLength(length))
                            tileObj.highlight.selectable();
                        else tileObj.highlight.invalid();
                        tileArr.push(tileObj);
                    }
                }
            }
            function highlightCurrentPlacement() {
                if (selectedTile === tile) {
                    tile.highlight.removableUnit();
                    highlightAllplacements();
                    return;
                }
                const tileArray = getTileArrayFrom(selectedTile, tile);
                let setInvalid = false;
                for (let i = 0; i < tileArray.length; i++) {
                    let tile = tileArray[i];
                    if (tile.unit.getUnit()) setInvalid = true;
                    if (setInvalid) return tile.highlight.invalid();
                    if (i >= 1 && !unitObj.getUnitOfLength(i + 1))
                        tile.highlight.invalid();
                    tile.highlight.validPlaceUnit();
                }
            }
            function highlightUnit(unit) {
                let tileArr = placedUnitsObj.getTileArrayFromPlacedUnit(unit);
                tileArr.forEach(tile => {
                    tile.highlight.removableUnit();
                })
            }
            function placeUnit() {
                const tileArray = getTileArrayFrom(selectedTile, tile);
                const unit = unitObj.getUnitOfLength(tileArray.length);
                if (!unit) return;                       //check if unit of length available
                for (let i = 0; i < tileArray.length; i++) {
                    let tile = tileArray[i];
                    if (tile.unit.getUnit()) return;          //check if any of the tiles have units
                    tile.unit.place(unit);
                }
                return true;
            }
            function getTileArrayFrom(tile1, tile2, limitByMaxLength = true) { //could be placed inside tile obj as getTileArrayTo
                if (tile1 === tile2) return [tile1];

                const startCoords = tile1.getCoordObj();
                const endCoords = tile2.getCoordObj();
                const xDif = endCoords.x - startCoords.x;
                const yDif = endCoords.y - startCoords.y;
                const inXAxis = Math.abs(yDif) <= Math.abs(xDif);

                let length;
                if (inXAxis) length = Math.abs(xDif);
                else length = Math.abs(yDif);
                if (limitByMaxLength && length >= unitObj.getMaxLength())
                    length = unitObj.getMaxLength() - 1; //-1 because starting at 0

                const tileArray = [tile1];
                let tempTile = tile1;

                for (let i = 0; i < length; i++) {
                    let direction;
                    if (!inXAxis && yDif <= 0) direction = 'up';
                    else if (!inXAxis) direction = 'down';
                    else if (xDif <= 0) direction = 'left'
                    else direction = 'right';
                    tempTile = tempTile.nextTile[direction]();
                    if (tempTile) tileArray.push(tempTile);
                }
                return tileArray;
            }

            function removeHighlights(tileClassObjArray) {
                while (tileClassObjArray.length > 0) {
                    let obj = tileClassObjArray.pop();
                    obj.tileNode.classList.remove(obj.className);
                }
            }
            function addHighlight(tileClassObjArray, className) {
                tileNode.classList.add(className);
                tileClassObjArray.push(new TileClassObj(tileNode, className))
            }
            return tile;
        }

    }
    function submitScene() {
        if (!unitObj.noUnitsAvailable()) return;
        const gameboard = playerObj.get.gameboard();
        const unitArray = unitObj.getPlacedUnits();
        unitArray.forEach(unit => {
            const gameUnit = unitObj.getRealUnitFromClone(unit);
            const tileArray = placedUnitsObj.getTileArrayFromPlacedUnit(unit);
            if (unit.get.length() === 1) { //shouldn't ever have a piece of length 1, but just in case
                gameboard.placeUnit(gameUnit, tileArray[0].getCoordArray());
                console.log(`There shouldn't be any units of length 1.`);
            }
            const startCoords = tileArray[0].getCoordObj();
            const endCoords = tileArray[tileArray.length - 1].getCoordObj();
            const inXaxis = startCoords.x === endCoords.x ? false : true;
            if (!gameboard.placeUnit(gameUnit, [startCoords.x, startCoords.y], !inXaxis)) {
                console.log('Error: trying to place unit on occupied tile.');
            }
        })
        loadNextScene();
    }
    function submitQuickSelect(){
        playerObj.ai.placeShips();
        loadNextScene();
    }
    function loadNextScene() {
        const scenes = _scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getScenes();
        if (_game_state__WEBPACK_IMPORTED_MODULE_1__["default"].get.game.isSinglePlayer()) {
            _game_state__WEBPACK_IMPORTED_MODULE_1__["default"].p2.ai.placeShips();
            _scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].loadScene(scenes.main.game);
            return;
        }
        if (playerRef === 'p2') {
            _scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].loadScene(scenes.main.game);
            return;
        } else {
            scenes.p2.piecePlacement = createScene('p2');
            _scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].loadScene(scenes.p2.piecePlacement);
            return;
        }
    }

    function TileClassObj(tileNode, className) {
        this.tileNode = tileNode;
        this.className = className;
    }

    function PlacedUnitsObj() {
        const placedUnitArr = [];

        this.pushUnit = (unit, tile) => {
            let placedUnit = placedUnitArr.find((placedUnit) => placedUnit.unit === unit);
            if (!placedUnit) {
                placedUnit = { unit, tileArr: [] };
                placedUnitArr.push(placedUnit);
            }
            let tileArr = placedUnit.tileArr;
            if (!tileArr.includes(tile)) tileArr.push(tile);
        }
        this.removeUnit = (unit) => {
            const index = placedUnitArr.findIndex((placedUnit) => placedUnit.unit === unit);
            if (index < 0) return false;
            unitObj.setUnitAvailable(unit);
            return placedUnitArr.splice(index, 1)[0];
        }
        this.getTileArrayFromPlacedUnit = (unit) => {
            const placedUnit = placedUnitArr.find((placedUnit) => placedUnit.unit === unit);
            if (!placedUnit) return [];
            sortTiles(placedUnit.tileArr)
            return placedUnit.tileArr;
        }
        function sortTiles(tileArr) {
            if (tileArr.length < 2) return;
            let axis = tileArr[0].getCoordObj().x === tileArr[1].getCoordObj().x ? 'y' : 'x';
            tileArr.sort((a, b) => a.getCoordObj()[axis] > b.getCoordObj()[axis])
        }
    }
}

function createUnitObj(unitArray) {
    const _availableUnits = [];
    const _placedUnits = [];
    let _maxLength = 0;
    let _minLength;
    //create semi-cloned units and fill unit array
    //  and set _maxLength
    unitArray.forEach((unit) => {
        _availableUnits.push(new CloneUnit(unit));
    })
    function CloneUnit(unit) {
        const id = unit.get.id();
        const length = unit.get.length();
        this.get = {
            id: () => id,
            length: () => length,
        };
    }
    function getUnitOfLength(length) {
        for (let i = 0; i < _availableUnits.length; i++) {
            if (_availableUnits[i].get.length() === length) return _availableUnits[i];
        }
        return false;
    }
    function setUnitPlaced(unit) {
        fromArrayToArray(_availableUnits, _placedUnits, unit);
        setLengthBounds();
    }
    function setUnitAvailable(unit) {
        fromArrayToArray(_placedUnits, _availableUnits, unit);
        setLengthBounds();
    }
    function setLengthBounds() {
        if (!_availableUnits.length) {
            _minLength = 0;
            _maxLength = 0;
            return;
        }
        _minLength = false;
        _maxLength = 0;
        for (let i = 0; i < _availableUnits.length; i++) {
            length = _availableUnits[i].get.length();
            if (_maxLength < length) _maxLength = length;
            if (!_minLength || _minLength > length) _minLength = length;
        }
    }
    function fromArrayToArray(fromArr, toArr, item) {
        const index = fromArr.indexOf(item);
        if (index < 0) return false;
        toArr.push(item);
        fromArr.splice(index, 1);
    }
    function getRealUnitFromClone(cloneUnit) {
        let id = cloneUnit.get.id();
        for (let i = 0; i < unitArray.length; i++) {
            if (id === unitArray[i].get.id())
                return unitArray[i];
        }
        return false;
    }
    const unitObj = {
        getAvailableUnitCount: () => _availableUnits.length,
        noUnitsAvailable: () => _availableUnits.length === 0,
        getPlacedUnits: () => _placedUnits,
        getMinLength: () => _minLength,
        getMaxLength: () => _maxLength,
        getUnitOfLength,
        setUnitPlaced,
        setUnitAvailable,
        getRealUnitFromClone,
    }
    setLengthBounds();
    return unitObj;
}

/***/ }),

/***/ "./src/scripts/scenes/player-select.js":
/*!*********************************************!*\
  !*** ./src/scripts/scenes/player-select.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scene_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scene-manager */ "./src/scripts/scene-manager.js");
/* harmony import */ var _player_factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../player-factory */ "./src/scripts/player-factory.js");
/* harmony import */ var _game_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../game-state */ "./src/scripts/game-state.js");





function initPlayerSelect() {
    let scene = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_0__.initScene)('TEMPLATE_player-select');
    const submitButton = scene.querySelector('[pSelectID="submit"]');
    const singlePlayerInput = scene.querySelector('[pSelectID="singlePlayer"]');
    const p1Input = scene.querySelector('[pSelectID="player1"]');
    const p2Input = scene.querySelector('[pSelectID="player2"]');


    submitButton.addEventListener('click', _onSubmit);
    function _onSubmit() {
        let singlePlayer = singlePlayerInput.checked;
        //p1
        let name = p1Input.value;
        if (name === '') name = 'Player1';
        let type = 'human';
        let player = (0,_player_factory__WEBPACK_IMPORTED_MODULE_1__["default"])(name, type);
        _game_state__WEBPACK_IMPORTED_MODULE_2__["default"].p1.set.player(player);

        //p2
        if (singlePlayer) {
            name = 'CPU';
            type = 'computer';
        }
        else {
            name = p2Input.value;
            if (name === '') name = 'Player 2';
        }
        player = (0,_player_factory__WEBPACK_IMPORTED_MODULE_1__["default"])(name, type);
        _game_state__WEBPACK_IMPORTED_MODULE_2__["default"].p2.set.player(player)
        //
        _game_state__WEBPACK_IMPORTED_MODULE_2__["default"].set.game.isSinglePlayer(singlePlayer);
        _scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].loadScene(_scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getScenes().p1.piecePlacement);
    }
    return scene;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initPlayerSelect);

/***/ }),

/***/ "./src/scripts/scenes/title-screen.js":
/*!********************************************!*\
  !*** ./src/scripts/scenes/title-screen.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scene_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scene-manager */ "./src/scripts/scene-manager.js");



function initTitleScreen() {
    let scene = (0,_scene_manager__WEBPACK_IMPORTED_MODULE_0__.initScene)('TEMPLATE_title-screen');
    document.body.addEventListener('click', _onButtonPress);
    document.body.addEventListener('keypress', _onButtonPress);

    function _onButtonPress() {
        document.body.removeEventListener('click', _onButtonPress);
        document.body.removeEventListener('keypress', _onButtonPress);
        if (_scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getCurrentScene() == scene) _scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].loadScene(_scene_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getScenes().main.playerSelect);
        else console.log(`Current scene is not titleScreen. Removing titleScreen event listeners and returning.`);
    }
    return scene;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (initTitleScreen);

/***/ }),

/***/ "./src/images/cat-black-moon-pattern-repeating.png":
/*!*********************************************************!*\
  !*** ./src/images/cat-black-moon-pattern-repeating.png ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__.p + "9b730c4d9de3300fd62e.png";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && !scriptUrl) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _styles_reset_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./styles/reset.css */ "./src/styles/reset.css");
/* harmony import */ var _styles_style_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styles/style.css */ "./src/styles/style.css");
/* harmony import */ var _scripts_scene_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scripts/scene-manager */ "./src/scripts/scene-manager.js");
/* harmony import */ var _scripts_game_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scripts/game-state */ "./src/scripts/game-state.js");







//setDummyUnits();
_scripts_scene_manager__WEBPACK_IMPORTED_MODULE_2__["default"].initializeScenes();
const scenes = _scripts_scene_manager__WEBPACK_IMPORTED_MODULE_2__["default"].getScenes();

_scripts_scene_manager__WEBPACK_IMPORTED_MODULE_2__["default"].loadScene(scenes.main.titleScreen);

//sceneManager.loadScene(scenes.p1.piecePlacement)
// sceneManager.loadScene(scenes.main.game);

})();

/******/ })()
;
//# sourceMappingURL=main.js.map